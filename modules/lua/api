B lpeg.B(patt)\nReturns a pattern that matches only if the input string at the current\nposition is preceded by `patt`. Pattern `patt` must match only strings with\nsome fixed length, and it cannot contain captures.\n\nLike the and predicate, this pattern never consumes any input, independently\nof success or failure.
C lpeg.C(patt)\nCreates a simple capture, which captures the substring of the subject that\nmatches `patt`. The captured value is a string. If `patt` has other captures,\ntheir values are returned after this one.
Carg lpeg.Carg(n)\nCreates an argument capture. This pattern matches the empty string and\nproduces the value given as the nth extra argument given in the call to\n`lpeg.match`.
Cb lpeg.Cb(name)\nCreates a back capture. This pattern matches the empty string and produces\nthe values produced by the most recent group capture named `name`.\n\nMost recent means the last complete outermost group capture with the given\nname. A Complete capture means that the entire pattern corresponding to the\ncapture has matched. An Outermost capture means that the capture is not\ninside another complete capture.\n\nIn the same way that LPeg does not specify when it evaluates captures, it\ndoes not specify whether it reuses values previously produced by the group or\nre-evaluates them.
Cc lpeg.Cc([value, ...])\nCreates a constant capture. This pattern matches the empty string and\nproduces all given values as its captured values.
Cf lpeg.Cf(patt, func)\nCreates a fold capture. If patt produces a list of captures C1 C2 ... Cn,\nthis capture will produce the value func(...func(func(C1, C2), C3)..., Cn),\nthat is, it will fold (or accumulate, or reduce) the captures from `patt`\nusing function `func`.\n\nThis capture assumes that `patt` should produce at least one capture with at\nleast one value (of any type), which becomes the initial value of an\naccumulator. (If you need a specific initial value, you may prefix a constant\ncapture to `patt`.) For each subsequent capture, LPeg calls `func` with this\naccumulator as the first argument and all values produced by the capture as\nextra arguments; the first result from this call becomes the new value for\nthe accumulator. The final value of the accumulator becomes the captured\nvalue.\n\nAs an example, the following pattern matches a list of numbers separated by\ncommas and returns their addition:\n\n  -- matches a numeral and captures its numerical value\n  number = lpeg.R"09"^1 / tonumber\n  -- matches a list of numbers, capturing their values\n  list = number * ("," * number)^0\n  -- auxiliary function to add two numbers\n  function add (acc, newvalue) return acc + newvalue end\n  -- folds the list of numbers adding them\n  sum = lpeg.Cf(list, add)\n  -- example of use\n  print(sum:match("10,30,43"))   --> 83
Cg lpeg.Cg(patt [, name])\nCreates a group capture. It groups all values returned by `patt` into a\nsingle capture. The group may be anonymous (if no name is given) or named\nwith the given name.\n\nAn anonymous group serves to join values from several captures into a single\ncapture. A named group has a different behavior. In most situations, a named\ngroup returns no values at all. Its values are only relevant for a following\nback capture or when used inside a table capture.
Cmt lpeg.Cmt(patt, function)\nCreates a match-time capture. Unlike all other captures, this one is\nevaluated immediately when a match occurs (even if it is part of a larger\npattern that fails later). It forces the immediate evaluation of all its\nnested captures and then calls `function`.\n\nThe given function gets as arguments the entire subject, the current position\n(after the match of `patt`), plus any capture values produced by `patt`.\n\nThe first value returned by `function` defines how the match happens. If the\ncall returns a number, the match succeeds and the returned number becomes the\nnew current position. (Assuming a subject s and current position i, the\nreturned number must be in the range [i, len(s) + 1].) If the call returns\ntrue, the match succeeds without consuming any input. (So, to return true is\nequivalent to return i.) If the call returns false, nil, or no value, the\nmatch fails.\n\nAny extra values returned by the function become the values produced by the\ncapture.
Cp lpeg.Cp()\nCreates a position capture. It matches the empty string and captures the\nposition in the subject where the match occurs. The captured value is a\nnumber.
Cs lpeg.Cs(patt)\nCreates a substitution capture, which captures the substring of the subject\nthat matches `patt`, with substitutions. For any capture inside `patt` with a\nvalue, the substring that matched the capture is replaced by the capture\nvalue (which should be a string). The final captured value is the string\nresulting from all replacements.
Ct lpeg.Ct(patt)\nCreates a table capture. This capture returns a table with all values from\nall anonymous captures made by `patt` inside this table in successive integer\nkeys, starting at 1. Moreover, for each named capture group created by\n`patt`, the first value of the group is put into the table with the group\nname as its key. The captured value is only the table.
P lpeg.P(value)\nConverts the given value into a proper pattern, according to the following\nrules:\n  * If the argument is a pattern, it is returned unmodified.\n  * If the argument is a string, it is translated to a pattern that matches\n    the string literally.\n  * If the argument is a non-negative number n, the result is a pattern that\n    matches exactly n characters.\n  * If the argument is a negative number -n, the result is a pattern that\n    succeeds only if the input string has less than n characters left:\n    `lpeg.P(-n)` is equivalent to `-lpeg.P(n)` (see the unary minus\n    operation).\n  * If the argument is a boolean, the result is a pattern that always\n    succeeds or always fails (according to the boolean value), without\n    consuming any input.\n  * If the argument is a table, it is interpreted as a grammar (see\n    Grammars).\n  * If the argument is a function, returns a pattern equivalent to a\n    match-time capture over the empty string.
R lpeg.R({range})\nReturns a pattern that matches any single character belonging to one of the\ngiven ranges. Each `range` is a string xy of length 2, representing all\ncharacters with code between the codes of x and y (both inclusive).\n\nAs an example, the pattern `lpeg.R("09")` matches any digit, and\n`lpeg.R("az", "AZ")` matches any ASCII letter.
S lpeg.S(string)\nReturns a pattern that matches any single character that appears in the given\nstring. (The S stands for Set.)\n\nAs an example, the pattern `lpeg.S("+-*/")` matches any arithmetic operator.\n\nNote that, if `s` is a character (that is, a string of length 1), then\n`lpeg.P(s)` is equivalent to `lpeg.S(s)` which is equivalent to\n`lpeg.R(s..s)`. Note also that both `lpeg.S("")` and `lpeg.R()` are patterns\nthat always fail.
V lpeg.V(v)\nThis operation creates a non-terminal (a variable) for a grammar. The created\nnon-terminal refers to the rule indexed by `v` in the enclosing grammar. (See\nGrammars for details.)
_G _G._G (module)\nLua _G module.
_G _G._G (table)\nA global variable (not a function) that holds the global environment\n(see §2.2). Lua itself does not use this variable; changing its value does\nnot affect any environment, nor vice versa.
_VERSION _G._VERSION (string)\nA global variable (not a function) that holds a string containing the\nrunning Lua version. The current value of this variable is "`Lua 5.3`".
abs math.abs(x)\nReturns the absolute value of `x`. (integer/float)
acos math.acos(x)\nReturns the arc cosine of `x` (in radians).
arshift bit32.arshift(x, disp)\nReturns the number `x` shifted `disp` bits to the right. The number `disp`\nmay be any representable integer. Negative displacements shift to the left.\n\nThis shift operation is what is called arithmetic shift. Vacant bits on the\nleft are filled with copies of the higher bit of `x`; vacant bits on the\nright are filled with zeros. In particular, displacements with absolute\nvalues higher than 31 result in zero or `0xFFFFFFFF` (all original bits are\nshifted out).\n\nNew in Lua 5.2.\nDeprecated in Lua 5.3.
asin math.asin(x)\nReturns the arc sine of `x` (in radians).
assert _G.assert(v [, message])\nCalls `error` if the value of its argument `v` is false (i.e., nil or false);\notherwise, returns all its arguments. In case of error, `message` is the\nerror object; when absent, it defaults to "assertion failed!".
atan math.atan(y [, x])\nReturns the arc tangent of `y/x` (in radians), but uses the signs\nof both parameters to find the quadrant of the result. (It also handles\ncorrectly the case of `x` being zero.)\n\nThe default value for `x` is 1, so that the call `math.atan(y)` returns the\narc tangent of `y`.
atan2 math.atan2(y, x)\nReturns the arc tangent of `y/x` (in radians), but uses the signs\nof both parameters to find the quadrant of the result. (It also handles\ncorrectly the case of `x` being zero.)\n\nDeprecated in Lua 5.3.
attributes lfs.attributes(filepath [, aname | atable])\nReturns a table with the file attributes corresponding to filepath (or nil\nfollowed by an error message in case of error). If the second optional\nargument is given and is a string, then only the value of the named attribute\nis returned (this use is equivalent to lfs.attributes(filepath)[aname], but\nthe table is not created and only one attribute is retrieved from the O.S.).\nIf a table is passed as the second argument, it is filled with attributes and\nreturned instead of a new table. The attributes are described as follows;\nattribute mode is a string, all the others are numbers, and the time related\nattributes use the same time reference of os.time:\n  dev: on Unix systems, this represents the device that the inode resides on.\n       On Windows systems, represents the drive number of the disk containing\n       the file\n  ino: on Unix systems, this represents the inode number. On Windows systems\n       this has no meaning\n  mode: string representing the associated protection mode (the values could\n        be file, directory, link, socket, named pipe, char device, block\n        device or other)\n  nlink: number of hard links to the file\n  uid: user-id of owner (Unix only, always 0 on Windows)\n  gid: group-id of owner (Unix only, always 0 on Windows)\n  rdev: on Unix systems, represents the device type, for special file inodes.\n        On Windows systems represents the same as dev\n  access: time of last access\n  modification: time of last data modification\n  change: time of last file status change\n  size: file size, in bytes\n  permissions: file permissions string\n  blocks: block allocated for file; (Unix only)\n  blksize: optimal file system I/O blocksize; (Unix only)\n\nThis function uses stat internally thus if the given filepath is a symbolic\nlink, it is followed (if it points to another link the chain is followed\nrecursively) and the information is about the file it refers to. To obtain\ninformation about the link itself, see function lfs.symlinkattributes.
band bit32.band(...)\nReturns the bitwise "and" of its operands.\n\nNew in Lua 5.2.\nDeprecated in Lua 5.3.
bit32 _G.bit32 (module)\nLua bit32 module.
bnot bit32.bnot(x)\nReturns the bitwise negation of `x`. For any integer `x`, the following\nidentity holds:\n\n  assert(bit32.bnot(x) == (-1 - x) % 2^32)\n\nNew in Lua 5.2.\nDeprecated in Lua 5.3.
bor bit32.bor(...)\nReturns the bitwise "or" of its operands.\n\nNew in Lua 5.2.\nDeprecated in Lua 5.3.
btest bit32.btest(...)\nReturns a boolean signaling whether the bitwise "and" of its operands is\ndifferent from zero.\n\nNew in Lua 5.2.\nDeprecated in Lua 5.3.
byte string.byte(s [, i [, j]])\nReturns the internal numerical codes of the characters `s[i]`, `s[i+1]`,\n···, `s[j]`. The default value for `i` is 1; the default value for `j`\nis `i`. These indices are corrected following the same rules of function\n`string.sub`.\n\nNumerical codes are not necessarily portable across platforms.
ceil math.ceil(x)\nReturns the smallest integral value larger than or equal to `x`.
char string.char(···)\nReceives zero or more integers. Returns a string with length equal to\nthe number of arguments, in which each character has the internal numerical\ncode equal to its corresponding argument.\n\nNumerical codes are not necessarily portable across platforms.
char utf8.char(···)\nReceives zero or more integers, converts each one to its corresponding UTF-8\nbyte sequence and returns a string with the concatenation of all these\nsequences.\n\nNew in Lua 5.3.
charpattern utf8.charpattern (string)\nThe pattern (a string, not a function) "\0-\x7F\xC2-\xF4*"\n(see §6.4.1), which matches exactly one UTF-8 byte sequence, assuming that\nthe subject is a valid UTF-8 string.\n\nNew in Lua 5.3.
chdir lfs.chdir(path)\nChanges the current working directory to the given path.\n\nReturns true in case of success or nil plus an error string.
clock os.clock()\nReturns an approximation of the amount in seconds of CPU time used by\nthe program.
close file:close()\nCloses `file`. Note that files are automatically closed when their\nhandles are garbage collected, but that takes an unpredictable amount of\ntime to happen.\n\nWhen closing a file handle created with `io.popen`, `file:close` returns the\nsame values returned by `os.execute`.
close io.close([file])\nEquivalent to `file:close()`. Without a `file`, closes the default\noutput file.
codepoint utf8.codepoint(s [, i [, j]])\nReturns the codepoints (as integers) from all characters in `s` that start\nbetween byte position `i` and `j` (both included). The default for `i` is 1\nand for `j` is `i`. It raises an error if it meets any invalid byte sequence.\n\nNew in Lua 5.3.
codes utf8.codes(s)\nReturns values so that the construction\n\n    for p, c in utf8.codes(s) do *body* end\n\nwill iterate over all characters in string `s`, with `p` being the position\n(in bytes) and `c` the code point of each character. It raises an error if it\nmeets any invalid byte sequence.\n\nNew in Lua 5.3.
collectgarbage _G.collectgarbage([opt [, arg]])\nThis function is a generic interface to the garbage collector. It\nperforms different functions according to its first argument, `opt`:\n  "collect": performs a full garbage-collection cycle. This is the default\n             option.\n  "stop": stops automatic execution of the garbage collector.\n  "restart": restarts automatic execution of the garbage collector.\n  "count": returns the total memory in use by Lua in Kbytes. The value has a\n           fractional part, so that it multiplied by 1024 gives the exact\n           number of bytes in use by Lua (except for overflows).\n  "step": performs a garbage-collection step. The step "size" is controlled\n          by `arg`. With a zero value, the collector will perform one basic\n          (indivisible) step. For non-zero values, the collector will perform\n          as if that amount of memory (in KBytes) had been allocated by Lua.\n          Returns true if the step finished a collection cycle.\n  "setpause": sets `arg` as the new value for the *pause* of the collector\n              (see §2.5). Returns the previous value for *pause*.\n  "setstepmul": sets `arg` as the new value for the *step multiplier*\n                of the collector (see §2.5). Returns the previous value for\n                *step*.\n  "isrunning": returns a boolean that tells whether the collector is running\n               (i.e., not stopped).
concat table.concat(list [, sep [, i [, j]]])\nGiven a list where all elements are strings or numbers, returns the string\n`list[i]..sep..list[i+1] ··· sep..list[j]`. The default value for `sep` is\nthe empty string, the default for `i` is 1, and the default for `j` is\n`#list`. If `i` is greater than `j`, returns the empty string.
config package.config (string)\nA string describing some compile-time configurations for packages. This\nstring is a sequence of lines:\n  The first line is the directory separator string. Default is '`\`' for\n  Windows and '`/`' for all other systems.\n  The second line is the character that separates templates in a path.\n  Default is '`;`'.\n  The third line is the string that marks the substitution points in a\n  template. Default is '`?`'.\n  The fourth line is a string that, in a path in Windows, is replaced by\n  the executable's directory. Default is '`!`'.\n  The fifth line is a mark to ignore all text after it when building the\n  `luaopen_` function name. Default is '`-`'.\n\nNew in Lua 5.2.
coroutine _G.coroutine (module)\nLua coroutine module.
cos math.cos(x)\nReturns the cosine of `x` (assumed to be in radians).
cosh math.cosh(x)\nReturns the hyperbolic cosine of `x`.\n\nDeprecated in Lua 5.3.
cpath package.cpath (string)\nThe path used by `require` to search for a C loader.\nLua initializes the C path `package.cpath` in the same way it initializes\nthe Lua path `package.path`, using the environment variable `LUA_CPATH_5_3`\nor the environment variable `LUA_CPATH` or a default path defined in\n`luaconf.h`.
create coroutine.create(f)\nCreates a new coroutine, with body `f`. `f` must be a Lua\nfunction. Returns this new coroutine, an object with type `"thread"`.
currentdir lfs.currentdir()\nReturns a string with the current working directory or nil plus an error\nstring.
date os.date([format [, time]])\nReturns a string or a table containing date and time, formatted according\nto the given string `format`.\n\nIf the `time` argument is present, this is the time to be formatted\n(see the `os.time` function for a description of this value). Otherwise,\n`date` formats the current time.\n\nIf `format` starts with '`!`', then the date is formatted in Coordinated\nUniversal Time. After this optional character, if `format` is the string\n"`*t`", then `date` returns a table with the following fields: `year`,\n`month` (1-12), `day` (1-31), `hour` (0-23), `min` (0-59), `sec` (0-61),\n`wday` (weekday, 1-7, Sunday is 1), `yday` (day of the year, 1-366), and\n`isdst` (daylight saving flag, a boolean). This last field may be absent if\nthe information is not available.\n\nIf `format` is not "`*t`", then `date` returns the date as a string,\nformatted according to the same rules as the ISO C function `strftime`.\n\nWhen called without arguments, `date` returns a reasonable date and time\nrepresentation that depends on the host system and on the current locale.\n(More specifically, `os.date()` is equivalent to `os.date("%c")`.)\n\nOn non-POSIX systems, this function may be not thread safe because of its\nreliance on C function `gmtime` and C function `localtime`.
debug _G.debug (module)\nLua debug module.
debug debug.debug()\nEnters an interactive mode with the user, running each string that\nthe user enters. Using simple commands and other debug facilities,\nthe user can inspect global and local variables, change their values,\nevaluate expressions, and so on. A line containing only the word `cont`\nfinishes this function, so that the caller continues its execution.\n\nNote that commands for `debug.debug` are not lexically nested within any\nfunction and so have no direct access to local variables.
deg math.deg(x)\nConverts the angle `x` from radians to degrees.
difftime os.difftime(t2, t1)\nReturns the difference, in seconds, from time `t1` to time `t2` (where the\ntimes are values returned by `os.time`). In POSIX, Windows, and some other\nsystems, this value is exactly `t2`*-*`t1`.
dir lfs.dir(path)\nLua iterator over the entries of a given directory. Each time the iterator is\ncalled with dir_obj it returns a directory entry's name as a string, or nil\nif there are no more entries. You can also iterate by calling dir_obj:next(),\nand explicitly close the directory before the iteration finished with\ndir_obj:close(). Raises an error if path is not a directory.
dofile _G.dofile([filename])\nOpens the named file and executes its contents as a Lua chunk. When\ncalled without arguments,\n`dofile` executes the contents of the standard input (`stdin`). Returns\nall values returned by the chunk. In case of errors, `dofile` propagates\nthe error to its caller (that is, `dofile` does not run in protected mode).
dump string.dump(function [, strip])\nReturns a string containing a binary representation (a _binary chunk_) of the\ngiven function, so that a later `load` on this string returns a copy of the\nfunction (but with new upvalues). If `strip` is a true value, the binary\nrepresentation is created without debug information about the function (local\nvariable names, lines, etc.).\n\nFunctions with upvalues have only their number of upvalues saved. When\n(re)loaded, those upvalues receive fresh instances containing nil. (You can\nuse the debug library to serialize and reload the upvalues of a function in a\nway adequate to your needs.)
error _G.error(message [, level])\nTerminates the last protected function called and returns `message`\nas the error object. Function `error` never returns.\n\nUsually, `error` adds some information about the error position at the\nbeginning of the message, if the message is a string. The `level` argument\nspecifies how to get the error position. With level 1 (the default), the\nerror position is where the `error` function was called. Level 2 points the\nerror to where the function that called `error` was called; and so on.\nPassing a level 0 avoids the addition of error position information to the\nmessage.
execute os.execute([command])\nThis function is equivalent to the ISO C function `system`. It passes\n`command` to be executed by an operating system shell. Its first result is\n`true` if the command terminated successfully, or `nil` otherwise. After this\nfirst result the function returns a string plus a number, as follows:\n  "exit": the command terminated normally; the following number is the exit\n          status of the command.\n  "signal": the command was terminated by a signal; the following number is\n            the signal that terminated the command.\n\nWhen called without a `command`, `os.execute` returns a boolean that is true\nif a shell is available.
exit os.exit([code [, close]])\nCalls the ISO C function `exit` to terminate the host program. If `code` is\n`true`, the returned status is `EXIT_SUCCESS`; if `code` is `false`, the\nreturned status is `EXIT_FAILURE`; if `code` is a number, the returned status\nis this number. The default value for `code` is `true`.\n\nIf the optional second argument `close` is true, closes the Lua state before\nexiting.
exp math.exp(x)\nReturns the value *e^x*.
extract bit32.extract(n, field [, width])\nReturns the unsigned number formed by the bits `field` to `field + width - 1`\nfrom `n`. Bits are numbered from 0 (least significant) to 31 (most\nsignificant). All accessed bits must be in the range [0, 31].\n\nThe default for `width` is 1.\n\nNew in Lua 5.2.\nDeprecated in Lua 5.3.
find string.find(s, pattern [, init [, plain]])\nLooks for the first match of `pattern` (see §6.4.1) in the string `s`. If it\nfinds a match, then `find` returns the indices of `s` where this occurrence\nstarts and ends; otherwise, it returns nil. A third, optional numerical\nargument `init` specifies where to start the search; its default value is 1\nand can be negative. A value of true as a fourth, optional argument `plain`\nturns off the pattern matching facilities, so the function does a plain\n"find substring" operation, with no characters in `pattern` being considered\nmagic. Note that if `plain` is given, then `init` must be given as well.\n\nIf the pattern has captures, then in a successful match the captured values\nare also returned, after the two indices.
floor math.floor(x)\nReturns the largest integral value smaller than or equal to `x`.
flush file:flush()\nSaves any written data to `file`.
flush io.flush()\nEquivalent to `io.output():flush()`.
fmod math.fmod(x, y)\nReturns the remainder of the division of `x` by `y` that rounds the\nquotient towards zero. (integer/float)
format string.format(formatstring, ···)\nReturns a formatted version of its variable number of arguments following the\ndescription given in its first argument (which must be a string). The format\nstring follows the same rules as the ISO C function `sprintf`. The only\ndifferences are that the options/modifiers `*`, `h`, `L`, `l`, `n`, and `p`\nare not supported and that there is an extra option, `q`.\n\nThe `q` option formats a string between double quotes, using escape sequences\nwhen necessary to ensure that it can safely be read back by the Lua\ninterpreter. For instance, the call\n\n  string.format('%q', 'a string with "quotes" and \\n new line')\n\nmay produce the string:\n\n  "a string with \"quotes\" and \\n      new line"\n\nOptions `A` and `a` (when available), `E`, `e`, `f`, `G`, and `g` all expect\na number as argument. Options `c`, `d`, `i`, `o`, `u`, `X`, and `x` expect an\ninteger. Option `q` expects a string. Option `s` expects a string; if its\nargument is not a string, it is converted to one following the same rules of\n`tostring`. If the option has any modifier (flags, width, length), the string\nargument should not contain zeros.
frexp math.frexp(x)\nReturns `m` and `e` such that 'x = m2^e', `e` is an integer and the\nabsolute value of `m` is in the range *[0.5, 1)* (or zero when `x` is zero).\n\nDeprecated in Lua 5.3.
getenv os.getenv(varname)\nReturns the value of the process environment variable `varname`, or\nnil if the variable is not defined.
getfenv _G.getfenv([f])\nReturns the current environment in use by the function. `f` can be a Lua\nfunction or a number that specifies the function at that stack level:\nLevel 1 is the function calling `getfenv`. If the given function is not a\nLua function, or if `f` is 0, `getfenv` returns the global environment. The\ndefault for `f` is 1.\n\nDeprecated in Lua 5.2.
getfenv debug.getfenv(o)\nReturns the environment of object `o`.\n\nDeprecated in Lua 5.2.
gethook debug.gethook([thread])\nReturns the current hook settings of the thread, as three values: the\ncurrent hook function, the current hook mask, and the current hook count\n(as set by the `debug.sethook` function).
getinfo debug.getinfo([thread, ] f [, what])\nReturns a table with information about a function. You can give the\nfunction directly or you can give a number as the value of `f`, which means\nthe function running at level `f` of the call stack of the given thread:\nlevel 0 is the current function (`getinfo` itself); level 1 is the function\nthat called `getinfo` and so on. If `f` is a number larger than the number of\nactive functions, then `getinfo` returns nil.\n\nThe returned table can contain all the fields returned by `lua_getinfo`,\nwith the string `what` describing which fields to fill in. The default for\n`what` is to get all information available, except the table of valid\nlines. If present, the option '`f`' adds a field named `func` with\nthe function itself. If present, the option '`L`' adds a field named\n`activelines` with the table of valid lines.\n\nFor instance, the expression `debug.getinfo(1,"n").name` returns a table\nwith a name for the current function, if a reasonable name can be found,\nand the expression `debug.getinfo(print)` returns a table with all available\ninformation about the `print` function.
getlocal debug.getlocal([thread, ] f, local)\nThis function returns the name and the value of the local variable with index\n`local` of the function at level `f` of the stack. This function accesses not\nonly explicit local variables, but also parameters, temporaries, etc.\n\nThe first parameter or local variable has index 1, and so on, following the\norder that they are declared in the code, counting only the variables that\nare active in the current scope of the function. Negative indices refer to\nvararg parameters; -1 is the first vararg parameter. The function returns nil\nif there is no variable with the given index, and raises an error when called\nwith a level out of range. (You can call `debug.getinfo` to check whether the\nlevel is valid.)\n\nVariable names starting with '(' (open parenthesis) represent variables with\nno known names (internal variables such as loop control variables, and\nvariables from chunks saved without debug information).\n\nThe parameter `f` may also be a function. In that case, `getlocal` returns\nonly the name of function parameters.
getmetatable _G.getmetatable(object)\nIf `object` does not have a metatable, returns nil. Otherwise, if the\nobject's metatable has a `__metatable` field, returns the associated\nvalue. Otherwise, returns the metatable of the given object.
getmetatable debug.getmetatable(value)\nReturns the metatable of the given `value` or nil if it does not have\na metatable.
getregistry debug.getregistry()\nReturns the registry table (see §4.5).
getupvalue debug.getupvalue(f, up)\nThis function returns the name and the value of the upvalue with index\n`up` of the function `f`. The function returns nil if there is no upvalue\nwith the given index.\n\nVariable names starting with '(' (open parenthesis) represent variables with\nno known names (variables from chunks saved without debug information).
getuservalue debug.getuservalue(u)\nReturns the Lua value associated to `u`. If `u` is not a userdata, returns\nnil.\n\nNew in Lua 5.2.
gmatch string.gmatch(s, pattern)\nReturns an iterator function that, each time it is called, returns the\nnext captures from `pattern` (see §6.4.1) over the string `s`. If `pattern`\nspecifies no captures, then the whole match is produced in each call.\n\nAs an example, the following loop will iterate over all the words from string\n`s`, printing one per line:\n\n  s = "hello world from Lua"\n  for w in string.gmatch(s, "%a+") do\n    print(w)\n  end\n\nThe next example collects all pairs `key=value` from the given string into a\ntable:\n\n  t = {}\n  s = "from=world, to=Lua"\n  for k, v in string.gmatch(s, "(%w+)=(%w+)") do\n    t[k] = v\n  end\n\nFor this function, a caret '`^`' at the start of a pattern does not work as\nan anchor, as this would prevent the iteration.
gsub string.gsub(s, pattern, repl [, n])\nReturns a copy of `s` in which all (or the first `n`, if given)\noccurrences of the `pattern` (see §6.4.1) have been replaced by a replacement\nstring specified by `repl`, which can be a string, a table, or a function.\n`gsub` also returns, as its second value, the total number of matches that\noccurred. The name `gsub` comes from "Global SUBstitution".\n\nIf `repl` is a string, then its value is used for replacement. The character\n`%` works as an escape character: any sequence in `repl` of the form `%d`,\nwith `d` between 1 and 9, stands for the value of the `d`-th captured\nsubstring. The sequence `%0` stands for the whole match. The sequence `%%`\nstands for a single `%`.\n\nIf `repl` is a table, then the table is queried for every match, using\nthe first capture as the key.\n\nIf `repl` is a function, then this function is called every time a match\noccurs, with all captured substrings passed as arguments, in order.\n\nIn any case, if the pattern specifies no captures, then it behaves as if the\nwhole pattern was inside a capture.\n\nIf the value returned by the table query or by the function call is a\nstring or a number, then it is used as the replacement string; otherwise,\nif it is false or nil, then there is no replacement (that is, the original\nmatch is kept in the string).\n\nHere are some examples:\n\n  x = string.gsub("hello world", "(%w+)", "%1 %1")\n  --> x="hello hello world world"\n  x = string.gsub("hello world", "%w+", "%0 %0", 1)\n  --> x="hello hello world"\n  x = string.gsub("hello world from Lua", "(%w+)%s*(%w+)", "%2 %1")\n  --> x="world hello Lua from"\n  x = string.gsub("home = $HOME, user = $USER", "%$(%w+)", os.getenv)\n  --> x="home = /home/roberto, user = roberto"\n  x = string.gsub("4+5 = $return 4+5$", "%$(.-)%$", function (s)\n        return load(s)()\n      end)\n  --> x="4+5 = 9"\n  local t = {name="lua", version="5.3"}\n  x = string.gsub("$name-$version.tar.gz", "%$(%w+)", t)\n  --> x="lua-5.3.tar.gz"
huge math.huge (number)\nThe float value `HUGE_VAL`, a value larger than any other numerical value.
input io.input([file])\nWhen called with a file name, it opens the named file (in text mode),\nand sets its handle as the default input file. When called with a file\nhandle, it simply sets this file handle as the default input file. When\ncalled without parameters, it returns the current default input file.\n\nIn case of errors this function raises the error, instead of returning an\nerror code.
insert table.insert(list, [pos, ] value)\nInserts element `value` at position `pos` in `list`, shifting up the elements\n`list[pos], list[pos+1], ···, list[#list]`. The default value for `pos` is\n`#list+1`, so that a call `table.insert(t,x)` inserts `x` at the end of list\n`t`.
io _G.io (module)\nLua io module.
ipairs _G.ipairs(t)\nReturns three values (an iterator function, the table `t`, and 0) so that the\nconstruction\n\n  for i,v in ipairs(t) do *body* end\n\nwill iterate over the key-value pairs (`1,t[1]`), (`2,t[2]`), ···, up to the\nfirst nil value.
isyieldable coroutine.isyieldable()\nReturns true when the running coroutine can yield.\n\nA running coroutine is yieldable if it is not the main thread and it is not\ninside a non-yieldable C function.\n\nNew in Lua 5.3.
ldexp math.ldexp(m, e)\nReturns 'm2^e' (`e` should be an integer).\n\nDeprecated in Lua 5.3.
len string.len(s)\nReceives a string and returns its length. The empty string `""` has\nlength 0. Embedded zeros are counted, so `"a\000bc\000"` has length 5.
len utf8.len(s [, i [, j]])\nReturns the number of UTF-8 characters in string `s` that start between\npositions `i` and `j` (both inclusive). The default for `i` is 1 and for `j`\nis -1. If it finds any invalid byte sequence, returns a false value plus the\nposition of the first invalid byte.\n\nNew in Lua 5.3.
lfs _G.lfs (module)\nLua lfs module.
lines file:lines(···)\nReturns an iterator function that, each time it is called, reads the file\naccording to the given formats. When no format is given, uses "l" as a\ndefault. As an example, the construction\n\n  for c in file:lines(1) do *body* end\n\nwill iterate over all characters of the file, starting at the current\nposition. Unlike `io.lines`, this function does not close the file when the\nloop ends.\n\nIn case of errors this function raises the error, instead of returning an\nerror code.
lines io.lines([filename, ···])\nOpens the given file name in read mode and returns an iterator function that\nworks like `file:lines(···)` over the opened file. When the iterator function\ndetects -- the end of file, it returns no values (to finish the loop) and\nautomatically closes the file.\n\nThe call `io.lines()` (with no file name) is equivalent to\n`io.input():lines("l")`; that is, it iterates over the lines of the default\ninput file. In this case it does not close the file when the loop ends.\n\nIn case of errors this function raises the error, instead of returning an\nerror code.
link lfs.link(old, new[, symlink])\nCreates a link. The first argument is the object to link to and the second is\nthe name of the link. If the optional third argument is true, the link will\nbe a symbolic link (by default, a hard link is created).
load _G.load(chunk [, chunkname [, mode [, env]]])\nLoads a chunk.\n\nIf `chunk` is a string, the chunk is this string. If `chunk` is a function, `load`\ncalls it repeatedly to get the chunk pieces. Each call to `chunk` must return a\nstring that concatenates with previous results. A return of an empty string,\nnil, or no value signals the end of the chunk.\n\nIf there are no syntactic errors, returns the compiled chunk as a function;\notherwise, returns nil plus the error message.\n\nIf the resulting function has upvalues, the first upvalue is set to the value\nof `env`, if that parameter is given, or to the value of the global\nenvironment. Other upvalues are initialized with nil. (When you load a main\nchunk, the resulting function will always have exactly one upvalue, the\n`_ENV` variable (see §2.2). However, when you load a binary chunk created\nfrom a function (see `string.dump`), the resulting function can have an\narbitrary number of upvalues.) All upvalues are fresh, that is, they are not\nshared with any other function.\n\n`chunkname` is used as the name of the chunk for error messages and debug\ninformation (see §4.9). When absent, it defaults to `chunk`, if `chunk` is a\nstring, or to "`=(load)`" otherwise.\n\nThe string `mode` controls whether the chunk can be text or binary (that is,\na precompiled chunk). It may be the string "`b`" (only binary chunks), "`t`"\n(only text chunks), or "`bt`" (both binary and text). The default is "`bt`".\n\nLua does not check the consistency of binary chunks. Maliciously crafted\nbinary chunks can crash the interpreter.
loaded package.loaded (table)\nA table used by `require` to control which modules are already loaded. When\nyou require a module `modname` and `package.loaded[modname]` is not false,\n`require` simply returns the value stored there.\nThis variable is only a reference to the real table; assignments to this\nvariable do not change the table used by `require`.
loaders package.loaders (table)\nSee `package.searchers`.\n\nDeprecated in Lua 5.2.
loadfile _G.loadfile([filename [, mode [, env]]])\nSimilar to `load`, but gets the chunk from file `filename` or from the\nstandard input, if no file name is given.
loadlib package.loadlib(libname, funcname)\nDynamically links the host program with the C library `libname`.\n\nIf `funcname` is "`*`", then it only links with the library, making the\nsymbols exported by the library available to other dynamically linked\nlibraries. Otherwise, it looks for a function `funcname` inside the library\nand returns this function as a C function. So, `funcname` must follow the\n`lua_CFunction` prototype (see `lua_CFunction`).\n\nThis is a low-level function. It completely bypasses the package and module\nsystem. Unlike `require`, it does not perform any path searching and does\nnot automatically adds extensions. `libname` must be the complete file name\nof the C library, including if necessary a path and an extension. `funcname`\nmust be the exact name exported by the C library (which may depend on the\nC compiler and linker used).\n\nThis function is not supported by Standard C. As such, it is only available\non some platforms (Windows, Linux, Mac OS X, Solaris, BSD, plus other Unix\nsystems that support the `dlfcn` standard).
loadstring _G.loadstring(string [, chunkname])\nSimilar to `load`, but gets the chunk from the given string. To load and\nrun a given string, use the idiom assert(loadstring(s))() When absent,\n`chunkname` defaults to the given string.\n\nDeprecated in Lua 5.2.
locale lpeg.locale([table])\nReturns a table with patterns for matching some character classes according\nto the current locale. The table has fields named `alnum`, `alpha`, `cntrl`,\n`digit`, `graph`, `lower`, `print`, `punct`, `space`, `upper`, and `xdigit`,\neach one containing a correspondent pattern. Each pattern matches any single\ncharacter that belongs to its class.\n\nIf called with an argument `table`, then it creates those fields inside the\ngiven table and returns that table.
lock lfs.lock(filehandle, mode[, start[, length]])\nLocks a file or a part of it. This function works on open files; the file\nhandle should be specified as the first argument. The string mode could be\neither r (for a read/shared lock) or w (for a write/exclusive lock). The\noptional arguments start and length can be used to specify a starting point\nand its length; both should be numbers.\n\nReturns true if the operation was successful; in case of error, it returns\nnil plus an error string.
lock_dir lfs.lock_dir(path, [seconds_stale])\nCreates a lockfile (called lockfile.lfs) in path if it does not exist and\nreturns the lock. If the lock already exists checks if it's stale, using the\nsecond parameter (default for the second parameter is INT_MAX, which in\npractice means the lock will never be stale. To free the the lock call\nlock:free().\n\nIn case of any errors it returns nil and the error message. In particular,\nif the lock exists and is not stale it returns the "File exists" message.
log math.log(x [, base])\nReturns the logarithm of `x` in the given base. The default for `base` is 'e'\n(so that the function returns the natural logarithm of `x`).
log10 math.log10(x)\nReturns the base-10 logarithm of `x`.\n\nDeprecated in Lua 5.2.
lower string.lower(s)\nReceives a string and returns a copy of this string with all uppercase\nletters changed to lowercase. All other characters are left unchanged. The\ndefinition of what an uppercase letter is depends on the current locale.
lpeg _G.lpeg (module)\nLua lpeg module.
lrotate bit32.lrotate(x, disp)\nReturns the number `x` rotated `disp` bits to the left. The number `disp` may\nbe any representable integer.\n\nFor any valid displacement, the following identity holds:\n\n  assert(bit32.lrotate(x, disp) == bit32.lrotate(x, disp % 32))\n\nIn particular, negative displacements rotate to the right.\n\nNew in Lua 5.2.\nDeprecated in Lua 5.3.
lshift bit32.lshift(x, disp)\nReturns the number `x` shifted `disp` bits to the left. The number `disp` may\nbe any representable integer. Negative displacements shift to the right. In\nany direction, vacant bits are filled with zeros. In particular,\ndisplacements with absolute values higher than 31 result in zero (all bits\nare shifted out).\n\nFor positive displacements, the following equality holds:\n\n  assert(bit32.lshift(b, disp) == (b * 2^disp) % 2^32)\n\nNew in Lua 5.2.\nDeprecated in Lua 5.3.
match lpeg.match(pattern, subject [, init])\nThe matching function. It attempts to match the given pattern against the\nsubject string. If the match succeeds, returns the index in the subject of\nthe first character after the match, or the captured values (if the pattern\ncaptured any value).\n\nAn optional numeric argument `init` makes the match start at that position in\nthe subject string. As usual in Lua libraries, a negative value counts from\nthe end.\n\nUnlike typical pattern-matching functions, match works only in anchored mode;\nthat is, it tries to match the pattern with a prefix of the given subject\nstring (at position `init`), not with an arbitrary substring of the subject.\nSo, if we want to find a pattern anywhere in a string, we must either write a\nloop in Lua or write a pattern that matches anywhere. This second approach is\neasy and quite efficient; see examples.
match string.match(s, pattern [, init])\nLooks for the first *match* of `pattern` (see §6.4.1) in the string `s`. If\nit finds one, then `match` returns the captures from the pattern; otherwise\nit returns nil. If `pattern` specifies no captures, then the whole match\nis returned. A third, optional numerical argument `init` specifies where\nto start the search; its default value is 1 and can be negative.
math _G.math (module)\nLua math module.
max math.max(x, ···)\nReturns the argument with the maximum value, according to the Lua operator\n`<`. (integer/float)
maxinteger math.maxinteger (number)\nAn integer with the maximum value for an integer.\n\nNew in Lua 5.3.
maxn table.maxn(table)\nReturns the largest positive numerical index of the given table, or zero if\nthe table has no positive numerical indices. (To do its job this function\ndoes a linear traversal of the whole table.)\n\nDeprecated in Lua 5.2.
min math.min(x, ···)\nReturns the argument with the minimum value, according to the Lua operator\n`<`. (integer/float)
mininteger math.mininteger (number)\nAn integer with the minimum value for an integer.\n\nNew in Lua 5.3.
mkdir lfs.mkdir(dirname)\nCreates a new directory. The argument is the name of the new directory.\n\nReturns true in case of success or nil, an error message and a\nsystem-dependent error code in case of error.
modf math.modf(x)\nReturns the integral part of `x` and the fractional part of `x`. Its second\nresult is always a float.
module _G.module(name [, ···])\nCreates a module. If there is a table in `package.loaded[name]`, this table\nis the module. Otherwise, if there is a global table `t` with the given name,\nthis table is the module. Otherwise creates a new table `t` and sets it as\nthe value of the global `name` and the value of `package.loaded[name]`. This\nfunction also initializes `t._NAME` with the given name, `t._M` with the\nmodule (`t` itself), and `t._PACKAGE` with the package name (the full module\nname minus last component; see below). Finally, `module` sets `t` as the new\nenvironment of the current function and the new value of\n`package.loaded[name]`, so that `require` returns `t`. If `name` is a\ncompound name (that is, one with components separated by dots), `module`\ncreates (or reuses, if they already exist) tables for each component. For\ninstance, if `name` is `a.b.c`, then `module` stores the module table in\nfield `c` of field `b` of global `a`. This function can receive optional\n*options* after the module name, where each option is a function to be\napplied over the module.\n\nDeprecated in Lua 5.2.
move table.move(a1, f, e, t [, a2])\nMoves elements from table `a1` to table `a2`, performing the equivalent to\nthe following multiple assignment: `a2[t], ··· = a1[f], ···, a1[e]`. The\ndefault for `a2` is `a1`. The destination range can overlap with the source\nrange. Index `f` must be positive.\n\nReturns the destination table `a2`.\n\nNew in Lua 5.3.
next _G.next(table [, index])\nAllows a program to traverse all fields of a table. Its first argument is\na table and its second argument is an index in this table. `next` returns\nthe next index of the table and its associated value. When called with nil\nas its second argument, `next` returns an initial index and its associated\nvalue. When called with the last index, or with nil in an empty table, `next`\nreturns nil. If the second argument is absent, then it is interpreted as\nnil. In particular, you can use `next(t)` to check whether a table is empty.\n\nThe order in which the indices are enumerated is not specified, *even for\nnumeric indices*. (To traverse a table in numeric order, use a numerical\n`for`.)\n\nThe behavior of `next` is undefined if, during the traversal, you assign any\nvalue to a non-existent field in the table. You may however modify existing\nfields. In particular, you may clear existing fields.
offset utf8.offset(s, n [, i])\nReturns the position (in bytes) where the encoding of the `n`-th character of\n`s` (counting from position `i`) starts. A negative `n` gets characters\nbefore position `i`. The default for `i` is 1 when `n` is non-negative and\n`#s + 1` otherwise, so that `utf8.offset(s, -n)` gets the offset of the\n`n`-th character from the end of the string. If the specified character is\nneither in the subject nor right after its end, the function returns nil.\n\nAs a special case, when `n` is 0 the function returns the start of the\nencoding of the character that contains the `i`-th byte of `s`.\n\nThis function assumes that `s` is a valid UTF-8 string.\n\nNew in Lua 5.3.
open io.open(filename [, mode])\nThis function opens a file, in the mode specified in the string `mode`. It\nreturns a new file handle, or, in case of errors, nil plus an error message.\n\nThe `mode` string can be any of the following:\n  "r": read mode (the default);\n  "w": write mode;\n  "a": append mode;\n  "r+": update mode, all previous data is preserved;\n  "w+": update mode, all previous data is erased;\n  "a+": append update mode, previous data is preserved, writing is only\n        allowed at the end of file.\n\nThe `mode` string can also have a '`b`' at the end, which is needed in\nsome systems to open the file in binary mode.
os _G.os (module)\nLua os module.
output io.output([file])\nSimilar to `io.input`, but operates over the default output file.
pack string.pack(fmt, v1, v2, ···)\nReturns a binary string containing the values `v1`, `v2`, etc. packed (that\nis, serialized in binary form) according to the format string `fmt` (see\n§6.4.2).\n\nNew in Lua 5.3.
pack table.pack(···)\nReturns a new table with all parameters stored into keys 1, 2, etc. and with\na field "`n`" with the total number of parameters. Note that the resulting\ntable may not be a sequence.\n\nNew in Lua 5.2.
package _G.package (module)\nLua package module.
packsize string.packsize(fmt)\nReturns the size of a string resulting from `string.pack` with the given\nformat. The format string cannot have the variable-length options 's' or 'z'\n(see §6.4.2).\n\nNew in Lua 5.3.
pairs _G.pairs(t)\nIf `t` has a metamethod `__pairs`, calls it with `t` as argument and returns\nthe first three results from the call.\n\nOtherwise, returns three values: the `next` function, the table `t`, and nil,\nso that the construction\n\n  for k,v in pairs(t) do *body* end\n\nwill iterate over all key–value pairs of table `t`.\n\nSee function `next` for the caveats of modifying the table during its\ntraversal.
path package.path (string)\nThe path used by `require` to search for a Lua loader.\nAt start-up, Lua initializes this variable with the value of the\nenvironment variable `LUA_PATH_5_3` or the environment variable `LUA_PATH`\nor with a default path defined in `luaconf.h`, if those environment\nvariables are not defined. Any "`;;`" in the value of the environment\nvariable is replaced by the default path.
pcall _G.pcall(f [, arg1, ···])\nCalls function `f` with the given arguments in *protected mode*. This\nmeans that any error inside `f` is not propagated; instead, `pcall` catches\nthe error and returns a status code. Its first result is the status code (a\nboolean), which is true if the call succeeds without errors. In such case,\n`pcall` also returns all results from the call, after this first result. In\ncase of any error, `pcall` returns false plus the error message.
pi math.pi (number)\nThe value of 'π'.
popen io.popen(prog [, mode])\nStarts program `prog` in a separated process and returns a file handle\nthat you can use to read data from this program (if `mode` is `"r"`,\nthe default) or to write data to this program (if `mode` is `"w"`).\n\nThis function is system dependent and is not available on all platforms.
pow math.pow(x, y)\nReturns *x^y*. (You can also use the expression `x^y` to compute this\nvalue.)\n\nDeprecated in Lua 5.3.
preload package.preload (table)\nA table to store loaders for specific modules (see `require`).\nThis variable is only a reference to the real table; assignments to this\nvariable do not change the table used by `require`.
print _G.print(···)\nReceives any number of arguments and prints their values to `stdout`, using\nthe `tostring` function to convert each argument to a string. `print` is not\nintended for formatted output, but only as a quick way to show a value,\nfor instance for debugging. For complete control over the output, use\n`string.format` and `io.write`.
rad math.rad(x)\nConverts the angle `x` from degrees to radians.
random math.random([m [, n]])\nWhen called without arguments, returns a pseudo-random float with uniform\ndistribution in the range [0,1). When called with two integers `m` and `n`,\n`math.random` returns a pseudo-random integer with uniform distribution in\nthe range `[m, n]. (The value `n-m` cannot be negative and must fit in a Lua\ninteger.) The call `math.random(n)` is equivalent to `math.random(1, n)`.\n\nThis function is an interface to the underling pseudo-random generator\nfunction provided by C.
randomseed math.randomseed(x)\nSets `x` as the "seed" for the pseudo-random generator: equal seeds\nproduce equal sequences of numbers.
rawequal _G.rawequal(v1, v2)\nChecks whether `v1` is equal to `v2`, without invoking the `__eq`\nmetamethod. Returns a boolean.
rawget _G.rawget(table, index)\nGets the real value of `table[index]`, without invoking the `__index`\nmetamethod. `table` must be a table; `index` may be any value.
rawlen _G.rawlen(v)\nReturns the length of the object `v`,\nwhich must be a table or a string,\nwithout invoking the `__len` metamethod.\nReturns an integer.\n\nNew in Lua 5.2.
rawset _G.rawset(table, index, value)\nSets the real value of `table[index]` to `value`, without invoking the\n`__newindex` metamethod. `table` must be a table, `index` any value different\nfrom nil and NaN, and `value` any Lua value.\n\nThis function returns `table`.
read file:read(···)\nReads the file `file`, according to the given formats, which specify\nwhat to read. For each format, the function returns a string or a number\nwith the characters read, or nil if it cannot read data with the specified\nformat. (In this latter case, the function does not read subsequent formats.)\nWhen called without formats, it uses a default format that reads the next\nline (see below).\n\nThe available formats are\n  "n": reads a numeral and returns it as a float or an integer, following the\n       lexical conventions of Lua. (The numeral may have leading spaces and a\n       sign.) This format always reads the longest input sequence that is a\n       valid prefix for a number; if that prefix does not form a valid number\n       (e.g., an empty string, "0x", or "3.4e-"), it is discarded and the\n       function returns nil.\n  "a": reads the whole file, starting at the current position. On end of\n       file, it returns the empty string.\n  "l": reads the next line skipping the end of line, returning nil on\n       end of file. This is the default format.\n  "L": reads the next line keeping the end-of-line character (if present),\n       returning nil on end of file.\n  *number*: reads a string with up to this number of bytes, returning nil on\n       end of file. If *number* is zero, it reads nothing and returns an\n       empty string, or nil on end of file.\n\nThe formats "l" and "L" should be used only for text files.
read io.read(···)\nEquivalent to `io.input():read(···)`.
remove os.remove(filename)\nDeletes the file (or empty directory, on POSIX systems) with the given name.\nIf this function fails, it returns nil, plus a string describing the error\nand the error code.
remove table.remove(list [, pos])\nRemoves from `list` the element at position `pos`, returning the value of the\nremoved element. When `pos` is an integer between 1 and `#list`, it shifts\ndown the elements `list[pos+1], list[pos+2], ···, list[#list]` and erases\nelement `list[#list]`; The index `pos` can also be 0 when `#list` is 0, or\n`#list + 1`; in those cases, the function erases the element `list[pos]`.\n\nThe default value for `pos` is `#list`, so that a call `table.remove(l)`\nremoves the last element of list `l`.
rename os.rename(oldname, newname)\nRenames file or directory named `oldname` to `newname`. If this function\nfails, it returns nil, plus a string describing the error and the error code.
rep string.rep(s, n [, sep])\nReturns a string that is the concatenation of `n` copies of the string `s`\nseparated by the string `sep`. The default value for `sep` is the empty\nstring (that is, no separator). Returns the empty string if `n` is not\npositive.\n\n(Note that it is very easy to exhaust the memory of your machine with a\nsingle call to this function.)
replace bit32.replace(n, v, field [, width])\nReturns a copy of `n` with the bits `field` to `field + width - 1` replaced\nby the value `v`. See `bit32.extract` for details about `field` and `width`.\n\nNew in Lua 5.2.\nDeprecated in Lua 5.3.
require _G.require(modname)\nLoads the given module. The function starts by looking into the\n`package.loaded` table to determine whether `modname` is already\nloaded. If it is, then `require` returns the value stored at\n`package.loaded[modname]`. Otherwise, it tries to find a *loader* for\nthe module.\n\nTo find a loader, `require` is guided by the `package.searchers` sequence. By\nchanging this sequence, we can change how `require` looks for a module. The\nfollowing explanation is based on the default configuration for\n`package.searchers`.\n\nFirst `require` queries `package.preload[modname]`. If it has a value,\nthis value (which must be a function) is the loader. Otherwise `require`\nsearches for a Lua loader using the path stored in `package.path`. If\nthat also fails, it searches for a C loader using the path stored in\n`package.cpath`. If that also fails, it tries an *all-in-one* loader (see\n`package.searchers`).\n\nOnce a loader is found, `require` calls the loader with two arguments:\n`modname` and an extra value dependent on how it got the loader. (If the\nloader came from a file, this extra value is the file name.) If the loader\nreturns any non-nil value, `require` assigns the returned value to\n`package.loaded[modname]`. If the loader does not return a non-nil value and\nhas not assigned any value to `package.loaded[modname]`, then `require`\nassigns true to this entry. In any case, `require` returns the final value of\n`package.loaded[modname]`.\n\nIf there is any error loading or running the module, or if it cannot find\nany loader for the module, then `require` raises an error.
resume coroutine.resume(co [, val1, ···])\nStarts or continues the execution of coroutine `co`. The first time\nyou resume a coroutine, it starts running its body. The values `val1`,\n··· are passed as the arguments to the body function. If the coroutine\nhas yielded, `resume` restarts it; the values `val1`, ··· are passed\nas the results from the yield.\n\nIf the coroutine runs without any errors, `resume` returns true plus any\nvalues passed to `yield` (when the coroutine yields) or any values returned\nby the body function (when the coroutine terminates). If there is any error,\n`resume` returns false plus the error message.
reverse string.reverse(s)\nReturns a string that is the string `s` reversed.
rmdir lfs.rmdir(dirname)\nRemoves an existing directory. The argument is the name of the directory.\n\nReturns true in case of success or nil, an error message and a\nsystem-dependent error code in case of error.
rrotate bit32.rrotate(x, disp)\nReturns the number `x` rotated `disp` bits to the right. The number `disp`\nmay be any representable integer.\n\nFor any valid displacement, the following identity holds:\n\n  assert(bit32.rrotate(x, disp) == bit32.rrotate(x, disp % 32))\n\nIn particular, negative displacements rotate to the left.\n\nNew in Lua 5.2.\nDeprecated in Lua 5.3.
rshift bit32.rshift(x, disp)\nReturns the number `x` shifted `disp` bits to the right. The number `disp`\nmay be any representable integer. Negative displacements shift to the left.\nIn any direction, vacant bits are filled with zeros. In particular,\ndisplacements with absolute values higher than 31 result in zero (all bits\nare shifted out).\n\nFor positive displacements, the following equality holds:\n\n  assert(bit32.rshift(b, disp) == math.floor(b % 2^32 / 2^disp))\n\nThis shift operation is what is called logical shift.\n\nNew in Lua 5.2.\nDeprecated in Lua 5.3.
running coroutine.running()\nReturns the running coroutine plus a boolean, true when the running coroutine\nis the main one.
searchers package.searchers (table)\nA table used by `require` to control how to load modules.\nEach entry in this table is a *searcher function*. When looking for a\nmodule, `require` calls each of these searchers in ascending order, with\nthe module name (the argument given to `require`) as its sole parameter.\nThe function can return another function (the module *loader*) plus an\nextra value that will be passed to that loader, or a string explaining why\nit did not find that module (or nil if it has nothing to say).\nLua initializes this table with four functions.\nThe first searcher simply looks for a loader in the `package.preload`\ntable.\nThe second searcher looks for a loader as a Lua library, using the path\nstored at `package.path`. The search is done as described in function\n`package.searchpath`.\nThe third searcher looks for a loader as a C library, using the path given\nby the variable `package.cpath`. Again, the search is done as described in\nfunction `package.searchpath`. For instance, if the C path is the string\n  "./?.so;./?.dll;/usr/local/?/init.so"\nthe searcher for module `foo` will try to open the files `./foo.so`,\n`./foo.dll`, and `/usr/local/foo/init.so`, in that order. Once it finds\na C library, this searcher first uses a dynamic link facility to link the\napplication with the library. Then it tries to find a C function inside the\nlibrary to be used as the loader. The name of this C function is the string\n"`luaopen_`" concatenated with a copy of the module name where each dot\nis replaced by an underscore. Moreover, if the module name has a hyphen,\nits suffix after (and including) the first hyphen is removed. For instance,\nif the module name is `a.b.c-v2.1 `, the function name will be\n`luaopen_a_b_c`. The fourth searcher tries an *all-in-one loader*. It\nsearches the C path for a library for the root name of the given module.\nFor instance, when requiring `a.b.c`, it will search for a C library for\n`a`. If found, it looks into it for an open function for the submodule; in\nour example, that would be `luaopen_a_b_c`. With this facility, a package\ncan pack several C submodules into one single library, with each submodule\nkeeping its original open function.\nAll searchers except the first one (preload) return as the extra value the\nfile name where the module was found, as returned by `package.searchpath`.\nThe first searcher returns no extra value.\n\nNew in Lua 5.2.
searchpath package.searchpath(name, path [, sep [, rep]])\nSearches for the given `name` in the given `path`.\n\nA path is a string containing a sequence of _templates_ separated by\nsemicolons. For each template, the function replaces each interrogation mark\n(if any) in the template with a copy of `name` wherein all occurrences of\n`sep` (a dot, by default) were replaced by `rep` (the system's directory\nseparator, by default), and then tries to open the resulting file name.\nFor instance, if the path is the string\n  "./?.lua;./?.lc;/usr/local/?/init.lua"\nthe search for the name `foo.a` will try to open the files `./foo/a.lua`,\n`./foo/a.lc`, and `/usr/local/foo/a/init.lua`, in that order.\nReturns the resulting name of the first file that it can open in read mode\n(after closing the file), or nil plus an error message if none succeeds.\n(This error message lists all file names it tried to open.)\n\nNew in Lua 5.2.
seeall package.seeall(module)\nSets a metatable for `module` with its `__index` field referring to the\nglobal environment, so that this module inherits values from the global\nenvironment. To be used as an option to function `module`.\n\nDeprecated in Lua 5.2.
seek file:seek([whence [, offset]])\nSets and gets the file position, measured from the beginning of the\nfile, to the position given by `offset` plus a base specified by the string\n`whence`, as follows:\n  "set": base is position 0 (beginning of the file);\n  "cur": base is current position;\n  "end": base is end of file;\n\nIn case of success, function `seek` returns the final file position,\nmeasured in bytes from the beginning of the file. If `seek` fails, it returns\nnil, plus a string describing the error.\n\nThe default value for `whence` is `"cur"`, and for `offset` is 0. Therefore,\nthe call `file:seek()` returns the current file position, without changing\nit; the call `file:seek("set")` sets the position to the beginning of the\nfile (and returns 0); and the call `file:seek("end")` sets the position\nto the end of the file, and returns its size.
select _G.select(index, ···)\nIf `index` is a number, returns all arguments after argument number\n`index`; a negative number indexes from the end (-1 is the last argument).\nOtherwise, `index` must be the string `"#"`, and `select` returns the total\nnumber of extra arguments it received.
setfenv _G.setfenv(f, table)\nSets the environment to be used by the given function. `f` can be a Lua\nfunction or a number that specifies the function at that stack level: Level 1\nis the function calling `setfenv`. `setfenv` returns the given function. As a\nspecial case, when `f` is 0 `setfenv` changes the environment of the running\nthread. In this case, `setfenv` returns no values.\n\nDeprecated in Lua 5.2.
setfenv debug.setfenv(object, table)\nSets the environment of the given `object` to the given `table`. Returns\n`object`.\n\nDeprecated in Lua 5.2.
sethook debug.sethook([thread, ] hook, mask [, count])\nSets the given function as a hook. The string `mask` and the number\n`count` describe when the hook will be called. The string mask may have any\ncombination of the following characters, with the given meaning:\n  "c": the hook is called every time Lua calls a function;\n  "r": the hook is called every time Lua returns from a function;\n  "l": the hook is called every time Lua enters a new line of code.\n\nMoreover, with a `count` different from zero, the hook is called also after\nevery `count` instructions.\n\nWhen called without arguments, `debug.sethook` turns off the hook.\n\nWhen the hook is called, its first parameter is a string describing\nthe event that has triggered its call: `"call"` (or `"tail call"`),\n`"return"`, `"line"`, and `"count"`. For line events, the hook also gets the\nnew line number as its second parameter. Inside a hook, you can call\n`getinfo` with level 2 to get more information about the running function\n(level 0 is the `getinfo` function, and level 1 is the hook function).
setlocal debug.setlocal([thread, ] level, local, value)\nThis function assigns the value `value` to the local variable with\nindex `local` of the function at level `level` of the stack. The function\nreturns nil if there is no local variable with the given index, and raises\nan error when called with a `level` out of range. (You can call `getinfo`\nto check whether the level is valid.) Otherwise, it returns the name of\nthe local variable.\n\nSee `debug.getlocal` for more information about variable indices and names.
setlocale os.setlocale(locale [, category])\nSets the current locale of the program. `locale` is a system-dependent string\nspecifying a locale; `category` is an optional string describing which\ncategory to change: `"all"`, `"collate"`, `"ctype"`, `"monetary"`,\n`"numeric"`, or `"time"`; the default category is `"all"`. The function\nreturns the name of the new locale, or nil if the request cannot be honored.\n\nIf `locale` is the empty string, the current locale is set to an\nimplementation-defined native locale. If `locale` is the string "`C`",\nthe current locale is set to the standard C locale.\n\nWhen called with nil as the first argument, this function only returns\nthe name of the current locale for the given category.\n\nThis function may not be thread safe because of its reliance on C function\n`setlocale`.
setmaxstack lpeg.setmaxstack(max)\nSets the maximum size for the backtrack stack used by LPeg to track calls and\nchoices. Most well-written patterns need little backtrack levels and\ntherefore you seldom need to change this maximum; but a few useful patterns\nmay need more space. Before changing this maximum you should try to rewrite\nyour pattern to avoid the need for extra space.
setmetatable _G.setmetatable(table, metatable)\nSets the metatable for the given table. (To change the metatable of other\ntypes from Lua code, you must use the debug library.) If `metatable` is nil,\nremoves the metatable of the given table. If the original metatable has a\n`__metatable` field, raises an error.\n\nThis function returns `table`.
setmetatable debug.setmetatable(value, table)\nSets the metatable for the given `value` to the given `table` (which\ncan be nil).
setmode lfs.setmode(file, mode)\nSets the writing mode for a file. The mode string can be either "binary" or\n"text". Returns true followed by the previous mode string for the file, or\nnil followed by an error string in case of errors.. On non-Windows platforms,\nwhere the two modes are identical, setting the mode has no effect, and the\nmode is always returned as binary.
setupvalue debug.setupvalue(f, up, value)\nThis function assigns the value `value` to the upvalue with index `up`\nof the function `f`. The function returns nil if there is no upvalue with the\ngiven index. Otherwise, it returns the name of the upvalue.
setuservalue debug.setuservalue(udata, value)\nSets the given `value` as the Lua value associated to the given `udata`.\n`udata` must be a full userdata.\n\nReturns `udata`.\n\nNew in Lua 5.2.
setvbuf file:setvbuf(mode [, size])\nSets the buffering mode for an output file. There are three available\nmodes:\n  "no": no buffering; the result of any output operation appears immediately.\n  "full": full buffering; output operation is performed only when the\n          buffer is full or when you explicitly `flush` the file (see\n          `io.flush`).\n  "line": line buffering; output is buffered until a newline is output or\n          there is any input from some special files (such as a terminal\n          device).\n\nFor the last two cases, `size` specifies the size of the buffer, in\nbytes. The default is an appropriate size.
sin math.sin(x)\nReturns the sine of `x` (assumed to be in radians).
sinh math.sinh(x)\nReturns the hyperbolic sine of `x`.\n\nDeprecated in Lua 5.3.
sort table.sort(list [, comp])\nSorts list elements in a given order, *in-place*, from `list[1]` to\n`list[#list]`. If `comp` is given, then it must be a function that receives\ntwo list elements and returns true when the first element must come before\nthe second in the final order (so that, after the sort, `i < j` implies\n`not comp(list[j],list[i])` will be true after the sort). If `comp` is not\ngiven, then the standard Lua operator `<` is used instead.\n\nNote that the `comp` function must not define a string partial order over the\nelements in the list; that is, it must be asymmetric and transitive.\nOtherwise, no valid sort may be possible.\n\nThe sort algorithm is not stable; that is, elements not comparable by the\ngiven order (e.g., equal elements) may have their relative positions changed\nby the sort.
sqrt math.sqrt(x)\nReturns the square root of `x`. (You can also use the expression `x^0.5`\nto compute this value.)
status coroutine.status(co)\nReturns the status of coroutine `co`, as a string: `"running"`, if\nthe coroutine is running (that is, it called `status`); `"suspended"`, if\nthe coroutine is suspended in a call to `yield`, or if it has not started\nrunning yet; `"normal"` if the coroutine is active but not running (that\nis, it has resumed another coroutine); and `"dead"` if the coroutine has\nfinished its body function, or if it has stopped with an error.
stderr io.stderr (file)\nStandard error.
stdin io.stdin (file)\nStandard in.
stdout io.stdout (file)\nStandard out.
string _G.string (module)\nLua string module.
sub string.sub(s, i [, j])\nReturns the substring of `s` that starts at `i` and continues until\n`j`; `i` and `j` can be negative. If `j` is absent, then it is assumed to\nbe equal to -1 (which is the same as the string length). In particular,\nthe call `string.sub(s,1,j)` returns a prefix of `s` with length `j`, and\n`string.sub(s, -i)` returns a suffix of `s` with length `i`.\n\nIf, after the translation of negative indices, `i` is less than 1, it is\ncorrected to 1. If `j` is greater than the string length, it is corrected to\nthat length. If, after these corrections, `i` is greater than `j`, the\nfunction returns the empty string.
symlinkattributes lfs.symlinkattributes(filepath [, aname])\nIdentical to lfs.attributes except that it obtains information about the link\nitself (not the file it refers to). It also adds a target field, containing\nthe file name that the symlink points to. On Windows this function does not\nyet support links, and is identical to lfs.attributes.
table _G.table (module)\nLua table module.
tan math.tan(x)\nReturns the tangent of `x` (assumed to be in radians).
tanh math.tanh(x)\nReturns the hyperbolic tangent of `x`.\n\nDeprecated in Lua 5.3.
time os.time([table])\nReturns the current time when called without arguments, or a time\nrepresenting the date and time specified by the given table. This table\nmust have fields `year`, `month`, and `day`, and may have fields `hour`\n(default is 12), `min` (default is 0), `sec` (default is 0), and `isdst`\n(default is nil). For a description of these fields, see the `os.date`\nfunction.\n\nThe returned value is a number, whose meaning depends on your system. In\nPOSIX, Windows, and some other systems, this number counts the number of\nseconds since some given start time (the "epoch"). In other systems, the\nmeaning is not specified, and the number returned by `time` can be used only\nas an argument to `os.date` and `os.difftime`.
tmpfile io.tmpfile()\nIn case of success, returns a handle for a temporary file. This file is\nopened in update mode and it is automatically removed when the program ends.
tmpname os.tmpname()\nReturns a string with a file name that can be used for a temporary\nfile. The file must be explicitly opened before its use and explicitly\nremoved when no longer needed.\n\nOn POSIX systems, this function also creates a file with that name, to avoid\nsecurity risks. (Someone else might create the file with wrong permissions in\nthe time between getting the name and creating the file.) You still have to\nopen the file to use it and to remove it (even if you do not use it).\n\nWhen possible, you may prefer to use `io.tmpfile`, which automatically\nremoves the file when the program ends.
tointeger math.tointeger(x)\nIf the value `x` is convertible to an integer, returns that integer.\nOtherwise, returns nil.\n\nNew in Lua 5.3.
tonumber _G.tonumber(e [, base])\nWhen called with no `base`, `tonumber` tries to convert its argument to a\nnumber. If the argument is already a number or a string convertible to a\nnumber, then `tonumber` returns this number; otherwise, it\nreturns nil.\n\nThe conversion of strings can result in integers or floats, according to the\nlexical conventions of Lua (see §3.1). (The string may have leading and\ntrailing spaces and a sign.)\n\nWhen called with `base`, then `e` must be a string to be interpreted as an\ninteger numeral in that base. The base may be any integer between 2 and 36,\ninclusive. In bases above 10, the letter '`A`' (in either upper or lower\ncase) represents 10, '`B`' represents 11, and so forth, with '`Z`'\nrepresenting 35. If the string `e` is not a valid numeral in the given base,\nthe function returns nil
tostring _G.tostring(v)\nReceives a value of any type and converts it to a string in a human-readable\nformat. Floats always produce strings with some floating-point indication\n(either a decimal dot or an exponent). (For complete control of how numbers\nare converted, use `string.format`.)\n\nIf the metatable of `v` has a `__tostring` field, then `tostring` calls the\ncorresponding value with `v` as argument, and uses the result of the call as\nits result.
touch lfs.touch(filepath [, atime [, mtime]])\nSet access and modification times of a file. This function is a bind to utime\nfunction. The first argument is the filename, the second argument (atime) is\nthe access time, and the third argument (mtime) is the modification time.\nBoth times are provided in seconds (which should be generated with Lua\nstandard function os.time). If the modification time is omitted, the access\ntime provided is used; if both times are omitted, the current time is used.\n\nReturns true in case of success or nil, an error message and a\nsystem-dependent error code in case of error.
traceback debug.traceback([thread, ] [message] [, level])\nIf `message` is present but is neither a string nor nil, this function\nreturns `message` without further processing. Otherwise, it returns a string\nwith a traceback of the call stack. The optional `message` string is appended\nat the beginning of the traceback. An optional `level` number tells at which\nlevel to start the traceback (default is 1, the function calling\n`traceback`).
type _G.type(v)\nReturns the type of its only argument, coded as a string. The possible\nresults of this function are "\n`nil`" (a string, not the value nil), "`number`", "`string`", "`boolean`",\n"`table`", "`function`", "`thread`", and "`userdata`".
type io.type(obj)\nChecks whether `obj` is a valid file handle. Returns the string `"file"`\nif `obj` is an open file handle, `"closed file"` if `obj` is a closed file\nhandle, or nil if `obj` is not a file handle.
type lpeg.type(value)\nIf the given value is a pattern, returns the string "pattern". Otherwise\nreturns nil.
type math.type(x)\nReturns "integer" if `x` is an integer, "float" if it is a float, or nil if\nx is not a number.\n\nNew in Lua 5.3.
ult math.ult(m, n)\nReturns a boolean, true if integer `m` is below integer `n` when they are\ncompared as unsigned integers.\n\nNew in Lua 5.3.
unlock lfs.unlock(filehandle[, start[, length]])\nUnlocks a file or a part of it. This function works on open files; the file\nhandle should be specified as the first argument. The optional arguments\nstart and length can be used to specify a starting point and its length; both\nshould be numbers.\n\nReturns true if the operation was successful; in case of error, it returns\nnil plus an error string.
unpack _G.unpack(list [, i [, j]])\nReturns the elements from the given table. This function is equivalent to\nreturn list[i], list[i+1], ···, list[j] except that the above code can\nbe written only for a fixed number of elements. By default, `i` is 1 and\n`j` is the length of the list, as defined by the length operator\n(see §2.5.5).\n\nDeprecated in Lua 5.2.
unpack string.unpack(fmt, s [, pos])\nReturns the values packed in string `s` (see `string.pack`) according to the\nformat string `fmt` (see §6.4.2). An optional `pos` marks where to start\nreading in `s` (default is 1). After the read values, this function also\nreturns the index of the first unread byte in `s`.\n\nNew in Lua 5.3.
unpack table.unpack(list [, i [, j]])\nReturns the elements from the given list. This function is equivalent to\n\n  return list[i], list[i+1], ···, list[j]\n\nBy default, `i` is 1 and `j` is `#list`.\n\nNew in Lua 5.2.
upper string.upper(s)\nReceives a string and returns a copy of this string with all lowercase\nletters changed to uppercase. All other characters are left unchanged. The\ndefinition of what a lowercase letter is depends on the current locale.
upvalueid debug.upvalueid(f, n)\nReturns a unique identifier (as a light userdata) for the upvalue numbered\n`n` from the given function.\n\nThese unique identifiers allow a program to check whether different closures\nshare upvalues. Lua closures that share an upvalue (that is, that access a\nsame external local variable) will return identical ids for those upvalue\nindices.\n\nNew in Lua 5.2.
upvaluejoin debug.upvaluejoin(f1, n1, f2, n2)\nMake the `n1`-th upvalue of the Lua closure `f1` refer to the `n2`-th upvalue\nof the Lua closure `f2`.\n\nNew in Lua 5.2.
utf8 _G.utf8 (module)\nLua utf8 module.
version lpeg.version()\nReturns a string with the running version of LPeg.
wrap coroutine.wrap(f)\nCreates a new coroutine, with body `f`. `f` must be a Lua\nfunction. Returns a function that resumes the coroutine each time it is\ncalled. Any arguments passed to the function behave as the extra arguments to\n`resume`. Returns the same values returned by `resume`, except the first\nboolean. In case of error, propagates the error.
write file:write(···)\nWrites the value of each of its arguments to `file`. The arguments must be\nstrings or numbers.\n\nIn case of success, this function returns `file`. Otherwise it returns nil\nplus a string describing the error.
write io.write(···)\nEquivalent to `io.output():write(···)`.
xor bit32.xor(...)\nReturns the bitwise "exclusive or" of its operands.\n\nNew in Lua 5.2.\nDeprecated in Lua 5.3.
xpcall _G.xpcall(f, msgh [, arg1, ···])\nThis function is similar to `pcall`, except that it sets a new message\nhandler `msgh`.
yield coroutine.yield(···)\nSuspends the execution of the calling coroutine. Any arguments to `yield` are\npassed as extra results to `resume`.