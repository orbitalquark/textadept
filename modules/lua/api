B lpeg.B(patt)\nReturns a pattern that matches only if the input string at the current position is preceded\nby `patt`. Pattern `patt` must match only strings with some fixed length, and it cannot\ncontain captures.\n\nLike the and predicate, this pattern never consumes any input, independently of success\nor failure.
C lpeg.C(patt)\nCreates a simple capture, which captures the substring of the subject that matches `patt`. The\ncaptured value is a string. If `patt` has other captures, their values are returned after\nthis one.
Carg lpeg.Carg(n)\nCreates an argument capture. This pattern matches the empty string and produces the value\ngiven as the nth extra argument given in the call to `lpeg.match`.
Cb lpeg.Cb(name)\nCreates a back capture. This pattern matches the empty string and produces the values produced\nby the most recent group capture named `name`.\n\nMost recent means the last complete outermost group capture with the given name. A Complete\ncapture means that the entire pattern corresponding to the capture has matched. An Outermost\ncapture means that the capture is not inside another complete capture.\n\nIn the same way that LPeg does not specify when it evaluates captures, it does not specify\nwhether it reuses values previously produced by the group or re-evaluates them.
Cc lpeg.Cc([value, ...])\nCreates a constant capture. This pattern matches the empty string and produces all given\nvalues as its captured values.
Cf lpeg.Cf(patt, func)\nCreates a fold capture. If patt produces a list of captures C1 C2 ... Cn, this capture will\nproduce the value func(...func(func(C1, C2), C3)..., Cn), that is, it will fold (or accumulate,\nor reduce) the captures from `patt` using function `func`.\n\nThis capture assumes that `patt` should produce at least one capture with at least one value\n(of any type), which becomes the initial value of an accumulator. (If you need a specific\ninitial value, you may prefix a constant capture to `patt`.) For each subsequent capture,\nLPeg calls `func` with this accumulator as the first argument and all values produced by\nthe capture as extra arguments; the first result from this call becomes the new value for\nthe accumulator. The final value of the accumulator becomes the captured value.\n\nAs an example, the following pattern matches a list of numbers separated by commas and\nreturns their addition:\n\n  -- matches a numeral and captures its numerical value\n  number = lpeg.R"09"^1 / tonumber\n  -- matches a list of numbers, capturing their values\n  list = number * ("," * number)^0\n  -- auxiliary function to add two numbers\n  function add (acc, newvalue) return acc + newvalue end\n  -- folds the list of numbers adding them\n  sum = lpeg.Cf(list, add)\n  -- example of use\n  print(sum:match("10,30,43"))   --> 83
Cg lpeg.Cg(patt [, name])\nCreates a group capture. It groups all values returned by `patt` into a single capture. The\ngroup may be anonymous (if no name is given) or named with the given name.\n\nAn anonymous group serves to join values from several captures into a single capture. A named\ngroup has a different behavior. In most situations, a named group returns no values at all. Its\nvalues are only relevant for a following back capture or when used inside a table capture.
Cmt lpeg.Cmt(patt, function)\nCreates a match-time capture. Unlike all other captures, this one is evaluated immediately\nwhen a match occurs (even if it is part of a larger pattern that fails later). It forces\nthe immediate evaluation of all its nested captures and then calls `function`.\n\nThe given function gets as arguments the entire subject, the current position (after the\nmatch of `patt`), plus any capture values produced by `patt`.\n\nThe first value returned by `function` defines how the match happens. If the call returns a\nnumber, the match succeeds and the returned number becomes the new current position. (Assuming\na subject s and current position i, the returned number must be in the range [i, len(s) +\n1].) If the call returns true, the match succeeds without consuming any input. (So, to return\ntrue is equivalent to return i.) If the call returns false, nil, or no value, the match fails.\n\nAny extra values returned by the function become the values produced by the capture.
Cp lpeg.Cp()\nCreates a position capture. It matches the empty string and captures the position in the\nsubject where the match occurs. The captured value is a number.
Cs lpeg.Cs(patt)\nCreates a substitution capture, which captures the substring of the subject that matches\n`patt`, with substitutions. For any capture inside `patt` with a value, the substring that\nmatched the capture is replaced by the capture value (which should be a string). The final\ncaptured value is the string resulting from all replacements.
Ct lpeg.Ct(patt)\nCreates a table capture. This capture returns a table with all values from all anonymous\ncaptures made by `patt` inside this table in successive integer keys, starting at 1. Moreover,\nfor each named capture group created by `patt`, the first value of the group is put into\nthe table with the group name as its key. The captured value is only the table.
P lpeg.P(value)\nConverts the given value into a proper pattern, according to the following rules:\n\n  * If the argument is a pattern, it is returned unmodified.\n  * If the argument is a string, it is translated to a pattern that matches the string\n    literally.\n  * If the argument is a non-negative number n, the result is a pattern that matches exactly\n    n characters.\n  * If the argument is a negative number -n, the result is a pattern that succeeds only if the\n    input string has less than n characters left: `lpeg.P(-n)` is equivalent to `-lpeg.P(n)`\n    (see the unary minus operation).\n  * If the argument is a boolean, the result is a pattern that always succeeds or always fails\n    (according to the boolean value), without consuming any input.\n  * If the argument is a table, it is interpreted as a grammar (see Grammars).\n  * If the argument is a function, returns a pattern equivalent to a match-time capture over\n    the empty string.
R lpeg.R({range})\nReturns a pattern that matches any single character belonging to one of the given ranges. Each\n`range` is a string xy of length 2, representing all characters with code between the codes\nof x and y (both inclusive).\n\nAs an example, the pattern `lpeg.R("09")` matches any digit, and `lpeg.R("az", "AZ")`\nmatches any ASCII letter.
S lpeg.S(string)\nReturns a pattern that matches any single character that appears in the given string. (The\nS stands for Set.)\n\nAs an example, the pattern `lpeg.S("+-*/")` matches any arithmetic operator.\n\nNote that, if `s` is a character (that is, a string of length 1), then `lpeg.P(s)` is equivalent\nto `lpeg.S(s)` which is equivalent to `lpeg.R(s..s)`. Note also that both `lpeg.S("")` and\n`lpeg.R()` are patterns that always fail.
V lpeg.V(v)\nThis operation creates a non-terminal (a variable) for a grammar. The created non-terminal\nrefers to the rule indexed by `v` in the enclosing grammar. (See Grammars for details.)
_G _G._G (module)\nLua _G module.
_G _G._G (table)\nA global variable (not a function) that holds the global environment (see §2.2). Lua\nitself does not use this variable; changing its value does not affect any environment,\nnor vice versa.
_VERSION _G._VERSION (string)\nA global variable (not a function) that holds a string containing the running Lua version. The\ncurrent value of this variable is "`Lua 5.4`".
abs math.abs(x)\nReturns the maximum value between `x` and `-x`. (integer/float)
acos math.acos(x)\nReturns the arc cosine of `x` (in radians).
arshift bit32.arshift(x, disp)\nReturns the number `x` shifted `disp` bits to the right. The number `disp` may be any\nrepresentable integer. Negative displacements shift to the left.\n\nThis shift operation is what is called arithmetic shift. Vacant bits on the left are filled\nwith copies of the higher bit of `x`; vacant bits on the right are filled with zeros. In\nparticular, displacements with absolute values higher than 31 result in zero or `0xFFFFFFFF`\n(all original bits are shifted out).\n\nNew in Lua 5.2. Deprecated in Lua 5.3.
asin math.asin(x)\nReturns the arc sine of `x` (in radians).
assert _G.assert(v [, message])\nRaises an error if the value of its argument `v` is false (i.e., nil or false); otherwise,\nreturns all its arguments. In case of error, `message` is the error object; when absent,\nit defaults to "assertion failed!".
atan math.atan(y [, x])\nReturns the arc tangent of `y/x` (in radians), but uses the signs of both parameters to find\nthe quadrant of the result. It also handles correctly the case of `x` being zero.\n\nThe default value for `x` is 1, so that the call `math.atan(y)` returns the arc tangent of `y`.
atan2 math.atan2(y, x)\nReturns the arc tangent of `y/x` (in radians), but uses the signs of both parameters to find\nthe quadrant of the result. (It also handles correctly the case of `x` being zero.)\n\nDeprecated in Lua 5.3.
attributes lfs.attributes(filepath [, aname | atable])\nReturns a table with the file attributes corresponding to filepath (or nil followed by\nan error message in case of error). If the second optional argument is given and is a\nstring, then only the value of the named attribute is returned (this use is equivalent to\nlfs.attributes(filepath)[aname], but the table is not created and only one attribute is\nretrieved from the O.S.). If a table is passed as the second argument, it is filled with\nattributes and returned instead of a new table. The attributes are described as follows;\nattribute mode is a string, all the others are numbers, and the time related attributes use\nthe same time reference of os.time:\n\n  dev: on Unix systems, this represents the device that the inode resides on. On Windows\n    systems, represents the drive number of the disk containing the file\n  ino: on Unix systems, this represents the inode number. On Windows systems this has no meaning\n  mode: string representing the associated protection mode (the values could be file,\n    directory, link, socket, named pipe, char device, block device or other)\n  nlink: number of hard links to the file\n  uid: user-id of owner (Unix only, always 0 on Windows)\n  gid: group-id of owner (Unix only, always 0 on Windows)\n  rdev: on Unix systems, represents the device type, for special file inodes. On Windows\n    systems represents the same as dev\n  access: time of last access\n  modification: time of last data modification\n  change: time of last file status change\n  size: file size, in bytes\n  permissions: file permissions string\n  blocks: block allocated for file; (Unix only)\n  blksize: optimal file system I/O blocksize; (Unix only)\n\nThis function uses stat internally thus if the given filepath is a symbolic link, it is\nfollowed (if it points to another link the chain is followed recursively) and the information\nis about the file it refers to. To obtain information about the link itself, see function\nlfs.symlinkattributes.
band bit32.band(...)\nReturns the bitwise "and" of its operands.\n\nNew in Lua 5.2. Deprecated in Lua 5.3.
bit32 _G.bit32 (module)\nLua bit32 module.
bnot bit32.bnot(x)\nReturns the bitwise negation of `x`. For any integer `x`, the following identity holds:\n\n  assert(bit32.bnot(x) == (-1 - x) % 2^32)\n\nNew in Lua 5.2. Deprecated in Lua 5.3.
bor bit32.bor(...)\nReturns the bitwise "or" of its operands.\n\nNew in Lua 5.2. Deprecated in Lua 5.3.
btest bit32.btest(...)\nReturns a boolean signaling whether the bitwise "and" of its operands is different from zero.\n\nNew in Lua 5.2. Deprecated in Lua 5.3.
byte string.byte(s [, i [, j]])\nReturns the internal numerical codes of the characters `s[i]`, `s[i+1]`, ···, `s[j]`. The\ndefault value for `i` is 1; the default value for `j` is `i`. These indices are corrected\nfollowing the same rules of function `string.sub`.\n\nNumerical codes are not necessarily portable across platforms.
ceil math.ceil(x)\nReturns the smallest integral value greater than or equal to `x`.
char string.char(···)\nReceives zero or more integers. Returns a string with length equal to the number of arguments,\nin which each character has the internal numerical code equal to its corresponding argument.\n\nNumerical codes are not necessarily portable across platforms.
char utf8.char(···)\nReceives zero or more integers, converts each one to its corresponding UTF-8 byte sequence\nand returns a string with the concatenation of all these sequences.\n\nNew in Lua 5.3.
charpattern utf8.charpattern (string)\nThe pattern (a string, not a function) "\0-\x7F\xC2-\xFD*" (see §6.4.1), which\nmatches exactly one UTF-8 byte sequence, assuming that the subject is a valid UTF-8 string.\n\nNew in Lua 5.3.
chdir lfs.chdir(path)\nChanges the current working directory to the given path.\n\nReturns true in case of success or nil plus an error string.
clock os.clock()\nReturns an approximation of the amount in seconds of CPU time used by the program, as returned\nby the underlying ISO C function `clock`.
close coroutine.close(co)\nCloses coroutine `co`, that is, closes all its pending to-be-closed variables and puts the\ncoroutine in a dead state. The given coroutine must be dead or suspended. In case of error\nclosing some variable, returns false plus the error object; otherwise returns true.
close file:close()\nCloses `file`. Note that files are automatically closed when their handles are garbage\ncollected, but that takes an unpredictable amount of time to happen.\n\nWhen closing a file handle created with `io.popen`, `file:close` returns the same values\nreturned by `os.execute`.
close io.close([file])\nEquivalent to `file:close()`. Without a `file`, closes the default output file.
codepoint utf8.codepoint(s [, i [, j [, lax]]])\nReturns the codepoints (as integers) from all characters in `s` that start between byte\nposition `i` and `j` (both included). The default for `i` is 1 and for `j` is `i`. It raises\nan error if it meets any invalid byte sequence.\n\nThis function only accepts valid sequences (well formed and not overlong). By default, it only\naccepts byte sequences that result in valid Unicode code points, rejecting values greater than\n`10FFFF` and surrogates. The boolean argument `lax` lifts these checks, so that all values\nup to `0x7FFFFFFF` are accepted. (Not well formed and overlong sequences are still rejected.)\n\nNew in Lua 5.3.
codes utf8.codes(s [, lax])\nReturns values so that the construction\n\n    for p, c in utf8.codes(s) do *body* end\n\nwill iterate over all UTF-8 characters in string `s`, with `p` being the position (in bytes) and\n`c` the code point of each character. It raises an error if it meets any invalid byte sequence.\n\nThis function only accepts valid sequences (well formed and not overlong). By default, it only\naccepts byte sequences that result in valid Unicode code points, rejecting values greater than\n`10FFFF` and surrogates. The boolean argument `lax` lifts these checks, so that all values\nup to `0x7FFFFFFF` are accepted. (Not well formed and overlong sequences are still rejected.)\n\nNew in Lua 5.3.
collectgarbage _G.collectgarbage([opt [, arg]])\nThis function is a generic interface to the garbage collector. It performs different functions\naccording to its first argument, `opt`:\n  "collect": performs a full garbage-collection cycle. This is the default option.\n  "stop": stops automatic execution of the garbage collector.\n  "restart": restarts automatic execution of the garbage collector.\n  "count": returns the total memory in use by Lua in Kbytes. The value has a fractional part,\n    so that it multiplied by 1024 gives the exact number of bytes in use by Lua.\n  "step": performs a garbage-collection step. The step "size" is controlled by `arg`. With a\n    zero value, the collector will perform one basic (indivisible) step. For non-zero values,\n    the collector will perform as if that amount of memory (in Kbytes) had been allocated\n    by Lua. Returns true if the step finished a collection cycle.\n  "isrunning": returns a boolean that tells whether the collector is running (i.e., not\n    stopped).\n  "incremental": change the collector mode to incremental. This option can be followed\n    by three numbers: the garbage-collector pause, the step multiplier, and the step size\n    (see §2.5.1). A zero means to not change that value.\n  "generational": change the collector mode to generational. This option can be followed\n    by two numbers: the garbage-collector minor multiplier and the major multiplier (see\n    §2.5.2). A zero means to not change that value.\n\nSee §2.5 for more details about garbage collection and some of these options.
concat table.concat(list [, sep [, i [, j]]])\nGiven a list where all elements are strings or numbers, returns the string\n`list[i]..sep..list[i+1] ··· sep..list[j]`. The default value for `sep` is the empty\nstring, the default for `i` is 1, and the default for `j` is `#list`. If `i` is greater than\n`j`, returns the empty string.
config package.config (string)\nA string describing some compile-time configurations for packages. This string is a sequence\nof lines:\n\n  * The first line is the directory separator string. Default is '`\`' for Windows and\n    '`/`' for all other systems.\n  * The second line is the character that separates templates in a path. Default is '`;`'.\n  * The third line is the string that marks the substitution points in a template. Default\n    is '`?`'.\n  * The fourth line is a string that, in a path in Windows, is replaced by the executable's\n    directory. Default is '`!`'.\n  * The fifth line is a mark to ignore all text after it when building the `luaopen_`\n    function name. Default is '`-`'.\n\nNew in Lua 5.2.
coroutine _G.coroutine (module)\nLua coroutine module.
cos math.cos(x)\nReturns the cosine of `x` (assumed to be in radians).
cosh math.cosh(x)\nReturns the hyperbolic cosine of `x`.\n\nDeprecated in Lua 5.3.
cpath package.cpath (string)\nA string with the path used by `require` to search for a C loader.\n\nLua initializes the C path `package.cpath` in the same way it initializes the Lua path\n`package.path`, using the environment variable `LUA_CPATH_5_4` or the environment variable\n`LUA_CPATH` or a default path defined in `luaconf.h`.
create coroutine.create(f)\nCreates a new coroutine, with body `f`. `f` must be a Lua function. Returns this new coroutine,\nan object with type `"thread"`.
currentdir lfs.currentdir()\nReturns a string with the current working directory or nil plus an error string.
date os.date([format [, time]])\nReturns a string or a table containing date and time, formatted according to the given string\n`format`.\n\nIf the `time` argument is present, this is the time to be formatted (see the `os.time`\nfunction for a description of this value). Otherwise, `date` formats the current time.\n\nIf `format` starts with '`!`', then the date is formatted in Coordinated Universal Time. After\nthis optional character, if `format` is the string "`*t`", then `date` returns a table with\nthe following fields: `year`, `month` (1-12), `day` (1-31), `hour` (0-23), `min` (0-59),\n`sec` (0-61, due to leap seconds), `wday` (weekday, 1-7, Sunday is 1), `yday` (day of the\nyear, 1-366), and `isdst` (daylight saving flag, a boolean). This last field may be absent\nif the information is not available.\n\nIf `format` is not "`*t`", then `date` returns the date as a string, formatted according to\nthe same rules as the ISO C function `strftime`.\n\nIf `format` is absent, it defaults to "`%c`", which gives a human-readable date and time\nrepresentation using the current locale.\n\nOn non-POSIX systems, this function may be not thread safe because of its reliance on C\nfunction `gmtime` and C function `localtime`.
debug _G.debug (module)\nLua debug module.
debug debug.debug()\nEnters an interactive mode with the user, running each string that the user enters. Using\nsimple commands and other debug facilities, the user can inspect global and local variables,\nchange their values, evaluate expressions, and so on. A line containing only the word `cont`\nfinishes this function, so that the caller continues its execution.\n\nNote that commands for `debug.debug` are not lexically nested within any function and so\nhave no direct access to local variables.
deg math.deg(x)\nConverts the angle `x` from radians to degrees.
difftime os.difftime(t2, t1)\nReturns the difference, in seconds, from time `t1` to time `t2` (where the times are values\nreturned by `os.time`). In POSIX, Windows, and some other systems, this value is exactly\n`t2`*-*`t1`.
dir lfs.dir(path)\nLua iterator over the entries of a given directory. Each time the iterator is called\nwith dir_obj it returns a directory entry's name as a string, or nil if there are no more\nentries. You can also iterate by calling dir_obj:next(), and explicitly close the directory\nbefore the iteration finished with dir_obj:close(). Raises an error if path is not a directory.
dofile _G.dofile([filename])\nOpens the named file and executes its content as a Lua chunk. When called without arguments,\n`dofile` executes the content of the standard input (`stdin`). Returns all values returned\nby the chunk. In case of errors, `dofile` propagates the error to its caller. (That is,\n`dofile` does not run in protected mode.)
dump string.dump(function [, strip])\nReturns a string containing a binary representation (a _binary chunk_) of the given function, so\nthat a later `load` on this string returns a copy of the function (but with new upvalues). If\n`strip` is a true value, the binary representation is created without debug information\nabout the function (local variable names, lines, etc.).\n\nFunctions with upvalues have only their number of upvalues saved. When (re)loaded, those\nupvalues receive fresh instances. (See the `load` function for details about how these\nupvalues are initialized. You can use the debug library to serialize and reload the upvalues\nof a function in a way adequate to your needs.)
error _G.error(message [, level])\nRaises an error (see §2.3) with `message` as the error object. This function never returns.\n\nUsually, `error` adds some information about the error position at the beginning of the\nmessage, if the message is a string. The `level` argument specifies how to get the error\nposition. With level 1 (the default), the error position is where the `error` function\nwas called. Level 2 points the error to where the function that called `error` was called;\nand so on. Passing a level 0 avoids the addition of error position information to the message.
execute os.execute([command])\nThis function is equivalent to the ISO C function `system`. It passes `command` to be\nexecuted by an operating system shell. Its first result is `true` if the command terminated\nsuccessfully, or `nil` otherwise. After this first result the function returns a string plus\na number, as follows:\n\n  * "exit": the command terminated normally; the following number is the exit status of\n    the command.\n  * "signal": the command was terminated by a signal; the following number is the signal\n    that terminated the command.\n\nWhen called without a `command`, `os.execute` returns a boolean that is true if a shell\nis available.
exit os.exit([code [, close]])\nCalls the ISO C function `exit` to terminate the host program. If `code` is `true`, the returned\nstatus is `EXIT_SUCCESS`; if `code` is `false`, the returned status is `EXIT_FAILURE`; if\n`code` is a number, the returned status is this number. The default value for `code` is `true`.\n\nIf the optional second argument `close` is true, closes the Lua state before exiting.
exp math.exp(x)\nReturns the value *e^x*.
extract bit32.extract(n, field [, width])\nReturns the unsigned number formed by the bits `field` to `field + width - 1` from `n`. Bits\nare numbered from 0 (least significant) to 31 (most significant). All accessed bits must be\nin the range [0, 31].\n\nThe default for `width` is 1.\n\nNew in Lua 5.2. Deprecated in Lua 5.3.
find string.find(s, pattern [, init [, plain]])\nLooks for the first match of `pattern` (see §6.4.1) in the string `s`. If it finds a match,\nthen `find` returns the indices of `s` where this occurrence starts and ends; otherwise,\nit returns nil. A third, optional numerical argument `init` specifies where to start the\nsearch; its default value is 1 and can be negative. A value of true as a fourth, optional\nargument `plain` turns off the pattern matching facilities, so the function does a plain\n"find substring" operation, with no characters in `pattern` being considered magic.\n\nIf the pattern has captures, then in a successful match the captured values are also returned,\nafter the two indices.
floor math.floor(x)\nReturns the largest integral value less than or equal to `x`.
flush file:flush()\nSaves any written data to `file`.
flush io.flush()\nEquivalent to `io.output():flush()`.
fmod math.fmod(x, y)\nReturns the remainder of the division of `x` by `y` that rounds the quotient towards\nzero. (integer/float)
format string.format(formatstring, ···)\nReturns a formatted version of its variable number of arguments following the description\ngiven in its first argument, which must be a string. The format string follows the same rules\nas the ISO C function `sprintf`. The only differences are that the conversion specifiers and\nmodifiers `*`, `h`, `L`, `l`, and `n` are not supported and that there is an extra specifier,\n`q`.\n\nThe specifier `q` formats booleans, nil, numbers, and strings in a way that the result is a\nvalid constant in Lua source code. Booleans and nil are written in the obvious way (`true`,\n`false`, `nil`). Floats are written in hexadecimal, to preserve full precision. A string is\nwritten between double quotes, using escape sequences when necessary to ensure that it can\nsafely be read back by the Lua interpreter. For instance, the call\n\n  string.format('%q', 'a string with "quotes" and \\n new line')\n\nmay produce the string:\n\n  "a string with \"quotes\" and \ new line"\n\nThis specifier does not support modifiers (flags, width, length).\n\nThe conversion specifiers `A` and `a` (when available), `E`, `e`, `f`, `G`, and `g` all\nexpect a number as argument. The specifiers `c`, `d`, `i`, `o`, `u`, `X`, and `x` expect an\ninteger. When Lua is compiled with a C89 compiler, the specifiers `A` and `a` (hexadecimal\nfloats) do not support modifiers.\n\nThe specifier `s` expects a string; if its argument is not a string, it is converted to one\nfollowing the same rules of `tostring`. If the specifier has any modifier, the corresponding\nstring argument should not contain zeros.\n\nThe specifier `p` formats the pointer returned by `lua_topointer`. That gives a unique string\nidentifier for tables, userdata, threads, strings, and functions. For other values (numbers,\nnil, booleans), this specifier results in a string representing the pointer `NULL`.
frexp math.frexp(x)\nReturns `m` and `e` such that 'x = m2^e', `e` is an integer and the absolute value of `m`\nis in the range *[0.5, 1)* (or zero when `x` is zero).\n\nDeprecated in Lua 5.3.
getenv os.getenv(varname)\nReturns the value of the process environment variable `varname`, or nil if the variable is\nnot defined.
getfenv _G.getfenv([f])\nReturns the current environment in use by the function. `f` can be a Lua function or a\nnumber that specifies the function at that stack level: Level 1 is the function calling\n`getfenv`. If the given function is not a Lua function, or if `f` is 0, `getfenv` returns\nthe global environment. The default for `f` is 1.\n\nDeprecated in Lua 5.2.
getfenv debug.getfenv(o)\nReturns the environment of object `o`.\n\nDeprecated in Lua 5.2.
gethook debug.gethook([thread])\nReturns the current hook settings of the thread, as three values: the current hook function,\nthe current hook mask, and the current hook count, as set by the `debug.sethook` function.\n\nReturns nil if there is no active hook.
getinfo debug.getinfo([thread, ] f [, what])\nReturns a table with information about a function. You can give the function directly or\nyou can give a number as the value of `f`, which means the function running at level `f`\nof the call stack of the given thread: level 0 is the current function (`getinfo` itself);\nlevel 1 is the function that called `getinfo` (except for tail calls, which do not count in\nthe stack); and so on. If `f` is a number greater than the number of active functions, then\n`getinfo` returns nil.\n\nThe returned table can contain all the fields returned by `lua_getinfo`, with the string\n`what` describing which fields to fill in. The default for `what` is to get all information\navailable, except the table of valid lines. If present, the option '`f`' adds a field named\n`func` with the function itself. If present, the option '`L`' adds a field named `activelines`\nwith the table of valid lines.\n\nFor instance, the expression `debug.getinfo(1,"n").name` returns a table with a name for the\ncurrent function, if a reasonable name can be found, and the expression `debug.getinfo(print)`\nreturns a table with all available information about the `print` function.
getlocal debug.getlocal([thread, ] f, local)\nThis function returns the name and the value of the local variable with index `local` of the\nfunction at level `f` of the stack. This function accesses not only explicit local variables,\nbut also parameters and temporary values.\n\nThe first parameter or local variable has index 1, and so on, following the order that\nthey are declared in the code, counting only the variables that are active in the current\nscope of the function. Compile-time constants may not appear in this listing, if they were\noptimized away by the compiler. Negative indices refer to vararg parameters; -1 is the first\nvararg parameter. The function returns nil if there is no variable with the given index,\nand raises an error when called with a level out of range. (You can call `debug.getinfo`\nto check whether the level is valid.)\n\nVariable names starting with '(' (open parenthesis) represent variables with no known names\n(internal variables such as loop control variables, and variables from chunks saved without\ndebug information).\n\nThe parameter `f` may also be a function. In that case, `getlocal` returns only the name of\nfunction parameters.
getmetatable _G.getmetatable(object)\nIf `object` does not have a metatable, returns nil. Otherwise, if the object's metatable\nhas a `__metatable` field, returns the associated value. Otherwise, returns the metatable\nof the given object.
getmetatable debug.getmetatable(value)\nReturns the metatable of the given `value` or nil if it does not have a metatable.
getregistry debug.getregistry()\nReturns the registry table (see §4.3).
getupvalue debug.getupvalue(f, up)\nThis function returns the name and the value of the upvalue with index `up` of the function\n`f`. The function returns nil if there is no upvalue with the given index.\n\n(For Lua functions, upvalues are the external local variables that the function uses, and\nthat are consequently included in its closure.)\n\nFor C functions, this function uses the empty string `""` as a name for all upvalues.\n\nVariable name '`?`' (interrogation mark) represents variables with no known names (variables\nfrom chunks saved without debug information).
getuservalue debug.getuservalue(u, n)\nReturns the `n`-th user value associated to the userdata `u` plus a boolean, false, if the\nuserdata does not have that value.\n\nNew in Lua 5.2.
gmatch string.gmatch(s, pattern [, init])\nReturns an iterator function that, each time it is called, returns the next captures from\n`pattern` (see §6.4.1) over the string `s`. If `pattern` specifies no captures, then the\nwhole match is produced in each call. A third, optional argument `init` specifies where to\nstart the search; its default value is 1 and can be negative.\n\nAs an example, the following loop will iterate over all the words from string `s`, printing\none per line:\n\n  s = "hello world from Lua" for w in string.gmatch(s, "%a+") do\n    print(w) end\n\nThe next example collects all pairs `key=value` from the given string into a table:\n\n  t = {} s = "from=world, to=Lua" for k, v in string.gmatch(s, "(%w+)=(%w+)") do\n    t[k] = v end\n\nFor this function, a caret '`^`' at the start of a pattern does not work as an anchor,\nas this would prevent the iteration.
gsub string.gsub(s, pattern, repl [, n])\nReturns a copy of `s` in which all (or the first `n`, if given) occurrences of the `pattern`\n(see §6.4.1) have been replaced by a replacement string specified by `repl`, which can be\na string, a table, or a function. `gsub` also returns, as its second value, the total number\nof matches that occurred. The name `gsub` comes from "Global SUBstitution".\n\nIf `repl` is a string, then its value is used for replacement. The character `%` works as an\nescape character: any sequence in `repl` of the form `%d`, with `d` between 1 and 9, stands\nfor the value of the `d`-th captured substring; the sequence `%0` stands for the whole match;\nthe sequence `%%` stands for a single `%`.\n\nIf `repl` is a table, then the table is queried for every match, using the first capture as\nthe key.\n\nIf `repl` is a function, then this function is called every time a match occurs, with all\ncaptured substrings passed as arguments, in order.\n\nIn any case, if the pattern specifies no captures, then it behaves as if the whole pattern\nwas inside a capture.\n\nIf the value returned by the table query or by the function call is a string or a number,\nthen it is used as the replacement string; otherwise, if it is false or nil, then there is\nno replacement (that is, the original match is kept in the string).\n\nHere are some examples:\n\n  x = string.gsub("hello world", "(%w+)", "%1 %1") --> x="hello hello world world" x =\n  string.gsub("hello world", "%w+", "%0 %0", 1) --> x="hello hello world" x = string.gsub("hello\n  world from Lua", "(%w+)%s*(%w+)", "%2 %1") --> x="world hello Lua from" x = string.gsub("home\n  = $HOME, user = $USER", "%$(%w+)", os.getenv) --> x="home = /home/roberto, user = roberto"\n  x = string.gsub("4+5 = $return 4+5$", "%$(.-)%$", function (s)\n        return load(s)() end)\n  --> x="4+5 = 9" local t = {name="lua", version="5.4"} x = string.gsub("$name-$version.tar.gz",\n  "%$(%w+)", t) --> x="lua-5.4.tar.gz"
huge math.huge (number)\nThe float value `HUGE_VAL`, a value greater than any other numerical value.
input io.input([file])\nWhen called with a file name, it opens the named file (in text mode), and sets its handle as\nthe default input file. When called with a file handle, it simply sets this file handle as the\ndefault input file. When called without parameters, it returns the current default input file.\n\nIn case of errors this function raises the error, instead of returning an error code.
insert table.insert(list, [pos, ] value)\nInserts element `value` at position `pos` in `list`, shifting up the elements `list[pos],\nlist[pos+1], ···, list[#list]`. The default value for `pos` is `#list+1`, so that a call\n`table.insert(t,x)` inserts `x` at the end of the list `t`.
io _G.io (module)\nLua io module.
ipairs _G.ipairs(t)\nReturns three values (an iterator function, the table `t`, and 0) so that the construction\n\n  for i,v in ipairs(t) do *body* end\n\nwill iterate over the key-value pairs (`1,t[1]`), (`2,t[2]`), ···, up to the first\nabsent index.
isyieldable coroutine.isyieldable([co])\nReturns true when the coroutine `co` can yield. The default for `co` is the running coroutine.\n\nA coroutine is yieldable if it is not the main thread and it is not inside a non-yieldable\nC function.\n\nNew in Lua 5.3.
ldexp math.ldexp(m, e)\nReturns 'm2^e' (`e` should be an integer).\n\nDeprecated in Lua 5.3.
len string.len(s)\nReceives a string and returns its length. The empty string `""` has length 0. Embedded zeros\nare counted, so `"a\000bc\000"` has length 5.
len utf8.len(s [, i [, j [, lax]]])\nReturns the number of UTF-8 characters in string `s` that start between positions `i` and `j`\n(both inclusive). The default for `i` is 1 and for `j` is -1. If it finds any invalid byte\nsequence, returns nil plus the position of the first invalid byte.\n\nThis function only accepts valid sequences (well formed and not overlong). By default, it only\naccepts byte sequences that result in valid Unicode code points, rejecting values greater than\n`10FFFF` and surrogates. The boolean argument `lax` lifts these checks, so that all values\nup to `0x7FFFFFFF` are accepted. (Not well formed and overlong sequences are still rejected.)\n\nNew in Lua 5.3.
lfs _G.lfs (module)\nLua lfs module.
lines file:lines(···)\nReturns an iterator function that, each time it is called, reads the file according to the\ngiven formats. When no format is given, uses "l" as a default. As an example, the construction\n\n  for c in file:lines(1) do *body* end\n\nwill iterate over all characters of the file, starting at the current position. Unlike\n`io.lines`, this function does not close the file when the loop ends.
lines io.lines([filename, ···])\nOpens the given file name in read mode and returns an iterator function that works like\n`file:lines(···)` over the opened file. When the iterator function fails to read any value,\nit automatically closes the file. Besides the iterator function, `io.lines` returns three other\nvalues: two nil values as placeholders, plus the created file handle. Therefore, when used in\na generic for loop, the file is closed also if the loop is interrupted by an error or a `break`.\n\nThe call `io.lines()` (with no file name) is equivalent to `io.input():lines("l")`; that is,\nit iterates over the lines of the default input file. In this case it does not close the\nfile when the loop ends.\n\nIn case of errors opening the file, this function raises the error, instead of returning an\nerror code.
link lfs.link(old, new[, symlink])\nCreates a link. The first argument is the object to link to and the second is the name of the\nlink. If the optional third argument is true, the link will be a symbolic link (by default,\na hard link is created).
load _G.load(chunk [, chunkname [, mode [, env]]])\nLoads a chunk.\n\nIf `chunk` is a string, the chunk is this string. If `chunk` is a function, `load` calls\nit repeatedly to get the chunk pieces. Each call to `chunk` must return a string that\nconcatenates with previous results. A return of an empty string, nil, or no value signals\nthe end of the chunk.\n\nIf there are no syntactic errors, `load` returns the compiled chunk as a function; otherwise,\nit returns nil plus the error message.\n\nWhen you load a main chunk, the resulting function will always have exactly one upvalue, the\n`_ENV` variable (see §2.2). However, when you load a binary chunk created from a function\n(see `string.dump`), the resulting function can have an arbitrary number of upvalues,\nand there is no guarantee that its first upvalue will be the `_ENV` variable. (A non-main\nfunction may not even have an `_ENV` upvalue.)\n\nRegardless, if the resulting function has any upvalues, its first upvalue is set to the\nvalue of `env`, if that parameter is given, or to the value of the global environment. Other\nupvalues are initialized with nil. All upvalues are fresh, that is, they are not shared with\nany other function.\n\n`chunkname` is used as the name of the chunk for error messages and debug information (see\n§4.7). When absent, it defaults to `chunk`, if `chunk` is a string, or to "`=(load)`"\notherwise.\n\nThe string `mode` controls whether the chunk can be text or binary (that is, a precompiled\nchunk). It may be the string "`b`" (only binary chunks), "`t`" (only text chunks), or "`bt`"\n(both binary and text). The default is "`bt`".\n\nIt is safe to load malformed binary chunks; `load` signals an appropriate error. However,\nLua does not check the consistency of the code inside binary chunks; running maliciously\ncrafted bytecode can crash the interpreter.
loaded package.loaded (table)\nA table used by `require` to control which modules are already loaded. When you require\na module `modname` and `package.loaded[modname]` is not false, `require` simply returns\nthe value stored there.\n\nThis variable is only a reference to the real table; assignments to this variable do not\nchange the table used by `require`.
loaders package.loaders (table)\nSee `package.searchers`.\n\nDeprecated in Lua 5.2.
loadfile _G.loadfile([filename [, mode [, env]]])\nSimilar to `load`, but gets the chunk from file `filename` or from the standard input,\nif no file name is given.
loadlib package.loadlib(libname, funcname)\nDynamically links the host program with the C library `libname`.\n\nIf `funcname` is "`*`", then it only links with the library, making the symbols exported\nby the library available to other dynamically linked libraries. Otherwise, it looks for\na function `funcname` inside the library and returns this function as a C function. So,\n`funcname` must follow the `lua_CFunction` prototype (see `lua_CFunction`).\n\nThis is a low-level function. It completely bypasses the package and module system. Unlike\n`require`, it does not perform any path searching and does not automatically adds\nextensions. `libname` must be the complete file name of the C library, including if necessary\na path and an extension. `funcname` must be the exact name exported by the C library (which\nmay depend on the C compiler and linker used).\n\nThis function is not supported by Standard C. As such, it is only available on some platforms\n(Windows, Linux, Mac OS X, Solaris, BSD, plus other Unix systems that support the `dlfcn`\nstandard).\n\nThis function is inherently insecure, as it allows Lua to call any function in any readable\ndynamic library in the system. (Lua calls any function assuming the function has a proper\nprototype and respects a proper protocol (see lua_CFunction). Therefore, calling an arbitrary\nfunction in an arbitrary dynamic library more often than not results in an access violation.)
loadstring _G.loadstring(string [, chunkname])\nSimilar to `load`, but gets the chunk from the given string. To load and run a given string,\nuse the idiom assert(loadstring(s))() When absent, `chunkname` defaults to the given string.\n\nDeprecated in Lua 5.2.
locale lpeg.locale([table])\nReturns a table with patterns for matching some character classes according to the current\nlocale. The table has fields named `alnum`, `alpha`, `cntrl`, `digit`, `graph`, `lower`,\n`print`, `punct`, `space`, `upper`, and `xdigit`, each one containing a correspondent\npattern. Each pattern matches any single character that belongs to its class.\n\nIf called with an argument `table`, then it creates those fields inside the given table and\nreturns that table.
lock lfs.lock(filehandle, mode[, start[, length]])\nLocks a file or a part of it. This function works on open files; the file handle should be\nspecified as the first argument. The string mode could be either r (for a read/shared lock)\nor w (for a write/exclusive lock). The optional arguments start and length can be used to\nspecify a starting point and its length; both should be numbers.\n\nReturns true if the operation was successful; in case of error, it returns nil plus an\nerror string.
lock_dir lfs.lock_dir(path, [seconds_stale])\nCreates a lockfile (called lockfile.lfs) in path if it does not exist and returns the lock. If\nthe lock already exists checks if it's stale, using the second parameter (default for the\nsecond parameter is INT_MAX, which in practice means the lock will never be stale. To free\nthe the lock call lock:free().\n\nIn case of any errors it returns nil and the error message. In particular, if the lock exists\nand is not stale it returns the "File exists" message.
log math.log(x [, base])\nReturns the logarithm of `x` in the given base. The default for `base` is 'e' (so that the\nfunction returns the natural logarithm of `x`).
log10 math.log10(x)\nReturns the base-10 logarithm of `x`.\n\nDeprecated in Lua 5.2.
lower string.lower(s)\nReceives a string and returns a copy of this string with all uppercase letters changed to\nlowercase. All other characters are left unchanged. The definition of what an uppercase\nletter is depends on the current locale.
lpeg _G.lpeg (module)\nLua lpeg module.
lrotate bit32.lrotate(x, disp)\nReturns the number `x` rotated `disp` bits to the left. The number `disp` may be any\nrepresentable integer.\n\nFor any valid displacement, the following identity holds:\n\n  assert(bit32.lrotate(x, disp) == bit32.lrotate(x, disp % 32))\n\nIn particular, negative displacements rotate to the right.\n\nNew in Lua 5.2. Deprecated in Lua 5.3.
lshift bit32.lshift(x, disp)\nReturns the number `x` shifted `disp` bits to the left. The number `disp` may be any\nrepresentable integer. Negative displacements shift to the right. In any direction, vacant\nbits are filled with zeros. In particular, displacements with absolute values higher than\n31 result in zero (all bits are shifted out).\n\nFor positive displacements, the following equality holds:\n\n  assert(bit32.lshift(b, disp) == (b * 2^disp) % 2^32)\n\nNew in Lua 5.2. Deprecated in Lua 5.3.
match lpeg.match(pattern, subject [, init])\nThe matching function. It attempts to match the given pattern against the subject string. If\nthe match succeeds, returns the index in the subject of the first character after the match,\nor the captured values (if the pattern captured any value).\n\nAn optional numeric argument `init` makes the match start at that position in the subject\nstring. As usual in Lua libraries, a negative value counts from the end.\n\nUnlike typical pattern-matching functions, match works only in anchored mode; that is, it\ntries to match the pattern with a prefix of the given subject string (at position `init`),\nnot with an arbitrary substring of the subject. So, if we want to find a pattern anywhere in\na string, we must either write a loop in Lua or write a pattern that matches anywhere. This\nsecond approach is easy and quite efficient; see examples.
match string.match(s, pattern [, init])\nLooks for the first *match* of the `pattern` (see §6.4.1) in the string `s`. If it finds one,\nthen `match` returns the captures from the pattern; otherwise it returns nil. If `pattern`\nspecifies no captures, then the whole match is returned. A third, optional numerical argument\n`init` specifies where to start the search; its default value is 1 and can be negative.
math _G.math (module)\nLua math module.
max math.max(x, ···)\nReturns the argument with the maximum value, according to the Lua operator `<`.
maxinteger math.maxinteger (number)\nAn integer with the maximum value for an integer.\n\nNew in Lua 5.3.
maxn table.maxn(table)\nReturns the largest positive numerical index of the given table, or zero if the table has\nno positive numerical indices. (To do its job this function does a linear traversal of the\nwhole table.)\n\nDeprecated in Lua 5.2.
min math.min(x, ···)\nReturns the argument with the minimum value, according to the Lua operator `<`.
mininteger math.mininteger (number)\nAn integer with the minimum value for an integer.\n\nNew in Lua 5.3.
mkdir lfs.mkdir(dirname)\nCreates a new directory. The argument is the name of the new directory.\n\nReturns true in case of success or nil, an error message and a system-dependent error code\nin case of error.
modf math.modf(x)\nReturns the integral part of `x` and the fractional part of `x`. Its second result is always\na float.
module _G.module(name [, ···])\nCreates a module. If there is a table in `package.loaded[name]`, this table is the\nmodule. Otherwise, if there is a global table `t` with the given name, this table is the\nmodule. Otherwise creates a new table `t` and sets it as the value of the global `name`\nand the value of `package.loaded[name]`. This function also initializes `t._NAME` with the\ngiven name, `t._M` with the module (`t` itself), and `t._PACKAGE` with the package name\n(the full module name minus last component; see below). Finally, `module` sets `t` as the\nnew environment of the current function and the new value of `package.loaded[name]`, so that\n`require` returns `t`. If `name` is a compound name (that is, one with components separated\nby dots), `module` creates (or reuses, if they already exist) tables for each component. For\ninstance, if `name` is `a.b.c`, then `module` stores the module table in field `c` of field\n`b` of global `a`. This function can receive optional *options* after the module name,\nwhere each option is a function to be applied over the module.\n\nDeprecated in Lua 5.2.
move table.move(a1, f, e, t [, a2])\nMoves elements from the table `a1` to the table `a2`, performing the equivalent to the\nfollowing multiple assignment: `a2[t], ··· = a1[f], ···, a1[e]`. The default for `a2`\nis `a1`. The destination range can overlap with the source range. Index `f` must be positive.\n\nReturns the destination table `a2`.\n\nNew in Lua 5.3.
next _G.next(table [, index])\nAllows a program to traverse all fields of a table. Its first argument is a table and its\nsecond argument is an index in this table. A call to `next` returns the next index of the\ntable and its associated value. When called with nil as its second argument, `next` returns\nan initial index and its associated value. When called with the last index, or with nil in\nan empty table, `next` returns nil. If the second argument is absent, then it is interpreted\nas nil. In particular, you can use `next(t)` to check whether a table is empty.\n\nThe order in which the indices are enumerated is not specified, *even for numeric indices*. (To\ntraverse a table in numeric order, use a numerical `for`.)\n\nThe behavior of `next` is undefined if, during the traversal, you assign any value to a\nnon-existent field in the table. You may however modify existing fields. In particular,\nyou may set existing fields to nil.
offset utf8.offset(s, n [, i])\nReturns the position (in bytes) where the encoding of the `n`-th character of `s` (counting\nfrom position `i`) starts. A negative `n` gets characters before position `i`. The default\nfor `i` is 1 when `n` is non-negative and `#s + 1` otherwise, so that `utf8.offset(s, -n)`\ngets the offset of the `n`-th character from the end of the string. If the specified character\nis neither in the subject nor right after its end, the function returns nil.\n\nAs a special case, when `n` is 0 the function returns the start of the encoding of the\ncharacter that contains the `i`-th byte of `s`.\n\nThis function assumes that `s` is a valid UTF-8 string.\n\nNew in Lua 5.3.
open io.open(filename [, mode])\nThis function opens a file, in the mode specified in the string `mode`. It returns a new\nfile handle, or, in case of errors, nil plus an error message.\n\nThe `mode` string can be any of the following:\n\n  * "r": read mode (the default);\n  * "w": write mode;\n  * "a": append mode;\n  * "r+": update mode, all previous data is preserved;\n  * "w+": update mode, all previous data is erased;\n  * "a+": append update mode, previous data is preserved, writing is only allowed at the\n    end of file.\n\nThe `mode` string can also have a '`b`' at the end, which is needed in some systems to open\nthe file in binary mode.
os _G.os (module)\nLua os module.
output io.output([file])\nSimilar to `io.input`, but operates over the default output file.
pack string.pack(fmt, v1, v2, ···)\nReturns a binary string containing the values `v1`, `v2`, etc. serialized in binary form\n(packed) according to the format string `fmt` (see §6.4.2).\n\nNew in Lua 5.3.
pack table.pack(···)\nReturns a new table with all parameters stored into keys 1, 2, etc. and with a field "`n`"\nwith the total number of parameters. Note that the resulting table may not be a sequence,\nif some arguments are nil.\n\nNew in Lua 5.2.
package _G.package (module)\nLua package module.
packsize string.packsize(fmt)\nReturns the size of a string resulting from `string.pack` with the given format. The format\nstring cannot have the variable-length options 's' or 'z' (see §6.4.2).\n\nNew in Lua 5.3.
pairs _G.pairs(t)\nIf `t` has a metamethod `__pairs`, calls it with `t` as argument and returns the first three\nresults from the call.\n\nOtherwise, returns three values: the `next` function, the table `t`, and nil, so that the\nconstruction\n\n  for k,v in pairs(t) do *body* end\n\nwill iterate over all key–value pairs of table `t`.\n\nSee function `next` for the caveats of modifying the table during its traversal.
path package.path (string)\nA string with the path used by `require` to search for a Lua loader.\n\nAt start-up, Lua initializes this variable with the value of the environment variable\n`LUA_PATH_5_4` or the environment variable `LUA_PATH` or with a default path defined in\n`luaconf.h`, if those environment variables are not defined. A "`;;`" in the value of the\nenvironment variable is replaced by the default path.
pcall _G.pcall(f [, arg1, ···])\nCalls the function `f` with the given arguments in *protected mode*. This means that any\nerror inside `f` is not propagated; instead, `pcall` catches the error and returns a status\ncode. Its first result is the status code (a boolean), which is true if the call succeeds\nwithout errors. In such case, `pcall` also returns all results from the call, after this\nfirst result. In case of any error, `pcall` returns false plus the error object. Note that\nerrors caught by `pcall` do not call a message handler.
pi math.pi (number)\nThe value of 'π'.
popen io.popen(prog [, mode])\nStarts the program `prog` in a separated process and returns a file handle that you can use\nto read data from this program (if `mode` is `"r"`, the default) or to write data to this\nprogram (if `mode` is `"w"`).\n\nThis function is system dependent and is not available on all platforms.
pow math.pow(x, y)\nReturns *x^y*. (You can also use the expression `x^y` to compute this value.)\n\nDeprecated in Lua 5.3.
preload package.preload (table)\nA table to store loaders for specific modules (see `require`).\n\nThis variable is only a reference to the real table; assignments to this variable do not\nchange the table used by `require`.
print _G.print(···)\nReceives any number of arguments and prints their values to `stdout`, converting each argument\nto a string following the same rules of `tostring`.\n\nThe function `print` is not intended for formatted output, but only as a quick way to show a\nvalue, for instance for debugging. For complete control over the output, use `string.format`\nand `io.write`.
rad math.rad(x)\nConverts the angle `x` from degrees to radians.
random math.random([m [, n]])\nWhen called without arguments, returns a pseudo-random float with uniform distribution in the\nrange [0,1). When called with two integers `m` and `n`, `math.random` returns a pseudo-random\ninteger with uniform distribution in the range `[m, n]. The call `math.random(n)`, for a\npositive `n`, is equivalent to `math.random(1,n)`. The call `math.random(0)` produces an\ninteger with all bits (pseudo)random.\n\nThis function uses the `xoshiro256**` algorithm to produce pseudo-random 64-bit integers,\nwhich are the results of calls with argument 0. Other results (ranges and floats) are unbiased\nextracted from these integers.\n\nLua initializes its pseudo-random generator with the equivalent of a call to `math.randomseed`\nwith no arguments, so that `math.random` should generate different sequences of results each\ntime the program runs.
randomseed math.randomseed([x [, y]])\nWhen called with at least one argument, the integer parameters `x` and `y` are joined into a\n128-bit *seed* that is used to reinitialize the pseudo-random generator; equal seeds produce\nequal sequences of numbers. The default for `y` is zero.\n\nWhen called with no arguments, Lua generates a seed with a weak attempt for randomness.\n\nThis function returns the two seed components that were effectively used, so that setting\nthem again repeats the sequence.\n\nTo ensure a required level of randomness to the initial state (or contrarily, to have\na deterministic sequence, for instance when debugging a program), you should call\n`math.randomseed` with explicit arguments.
rawequal _G.rawequal(v1, v2)\nChecks whether `v1` is equal to `v2`, without invoking the `__eq` metamethod. Returns a boolean.
rawget _G.rawget(table, index)\nGets the real value of `table[index]`, without using the `__index` metavalue. `table` must\nbe a table; `index` may be any value.
rawlen _G.rawlen(v)\nReturns the length of the object `v`, which must be a table or a string, without invoking the\n`__len` metamethod. Returns an integer.\n\nNew in Lua 5.2.
rawset _G.rawset(table, index, value)\nSets the real value of `table[index]` to `value`, without using the `__newindex`\nmetavalue. `table` must be a table, `index` any value different from nil and NaN, and `value`\nany Lua value.\n\nThis function returns `table`.
read file:read(···)\nReads the file `file`, according to the given formats, which specify what to read. For each\nformat, the function returns a string or a number with the characters read, or nil if it\ncannot read data with the specified format. (In this latter case, the function does not read\nsubsequent formats.)  When called without arguments, it uses a default format that reads\nthe next line (see below).\n\nThe available formats are\n\n  * "n": reads a numeral and returns it as a float or an integer, following the lexical\n    conventions of Lua. (The numeral may have leading whitespaces and a sign.) This format\n    always reads the longest input sequence that is a valid prefix for a number; if that\n    prefix does not form a valid number (e.g., an empty string, "0x", or "3.4e-") or it is\n    too long (more than 200 characters), it is discarded and the format returns nil.\n  * "a": reads the whole file, starting at the current position. On end of file, it returns\n    the empty string; this format never fails.\n  * "l": reads the next line skipping the end of line, returning nil on end of file. This\n    is the default format.\n  * "L": reads the next line keeping the end-of-line character (if present), returning nil\n    on end of file.\n  * *number*: reads a string with up to this number of bytes, returning nil on end of file. If\n    *number* is zero, it reads nothing and returns an empty string, or nil on end of file.\n\nThe formats "l" and "L" should be used only for text files.
read io.read(···)\nEquivalent to `io.input():read(···)`.
remove os.remove(filename)\nDeletes the file (or empty directory, on POSIX systems) with the given name. If this function\nfails, it returns nil, plus a string describing the error and the error code.
remove table.remove(list [, pos])\nRemoves from `list` the element at position `pos`, returning the value of the removed\nelement. When `pos` is an integer between 1 and `#list`, it shifts down the elements\n`list[pos+1], list[pos+2], ···, list[#list]` and erases element `list[#list]`; The index\n`pos` can also be 0 when `#list` is 0, or `#list + 1`.\n\nThe default value for `pos` is `#list`, so that a call `table.remove(l)` removes the last\nelement of the list `l`.
rename os.rename(oldname, newname)\nRenames file or directory named `oldname` to `newname`. If this function fails, it returns\nnil, plus a string describing the error and the error code.
rep string.rep(s, n [, sep])\nReturns a string that is the concatenation of `n` copies of the string `s` separated by the\nstring `sep`. The default value for `sep` is the empty string (that is, no separator). Returns\nthe empty string if `n` is not positive.\n\n(Note that it is very easy to exhaust the memory of your machine with a single call to\nthis function.)
replace bit32.replace(n, v, field [, width])\nReturns a copy of `n` with the bits `field` to `field + width - 1` replaced by the value\n`v`. See `bit32.extract` for details about `field` and `width`.\n\nNew in Lua 5.2. Deprecated in Lua 5.3.
require _G.require(modname)\nLoads the given module. The function starts by looking into the `package.loaded` table to\ndetermine whether `modname` is already loaded. If it is, then `require` returns the value\nstored at `package.loaded[modname]`. (The absence of a second result in this case signals\nthat this call did not have to load the module.) Otherwise, it tries to find a *loader*\nfor the module.\n\nTo find a loader, `require` is guided by the table `package.searchers`. Each item in this\ntable is a search function, that searches for the module in a particular way. By changing\nthis table, we can change how `require` looks for a module. The following explanation is\nbased on the default configuration for `package.searchers`.\n\nFirst `require` queries `package.preload[modname]`. If it has a value, this value (which must be\na function) is the loader. Otherwise `require` searches for a Lua loader using the path stored\nin `package.path`. If that also fails, it searches for a C loader using the path stored in\n`package.cpath`. If that also fails, it tries an *all-in-one* loader (see `package.searchers`).\n\nOnce a loader is found, `require` calls the loader with two arguments: `modname` and an\nextra value, a *loader data*, also returned by the searcher. The loader data can be any\nvalue useful to the module; for the default searchers, it indicates where the loader\nwas found. (For instance, if the loader came from a file, this extra value is the file\npath.) If the loader returns any non-nil value, `require` assigns the returned value to\n`package.loaded[modname]`. If the loader does not return a non-nil value and has not assigned\nany value to `package.loaded[modname]`, then `require` assigns true to this entry. In any\ncase, `require` returns the final value of `package.loaded[modname]`. Besides that value,\n`require` also returns as a second result the loader data returned by the searcher, which\nindicates how `require` found the module.\n\nIf there is any error loading or running the module, or if it cannot find any loader for\nthe module, then `require` raises an error.
resume coroutine.resume(co [, val1, ···])\nStarts or continues the execution of coroutine `co`. The first time you resume a coroutine,\nit starts running its body. The values `val1`, ··· are passed as the arguments to the body\nfunction. If the coroutine has yielded, `resume` restarts it; the values `val1`, ··· are\npassed as the results from the yield.\n\nIf the coroutine runs without any errors, `resume` returns true plus any values passed to\n`yield` (when the coroutine yields) or any values returned by the body function (when the\ncoroutine terminates). If there is any error, `resume` returns false plus the error message.
reverse string.reverse(s)\nReturns a string that is the string `s` reversed.
rmdir lfs.rmdir(dirname)\nRemoves an existing directory. The argument is the name of the directory.\n\nReturns true in case of success or nil, an error message and a system-dependent error code\nin case of error.
rrotate bit32.rrotate(x, disp)\nReturns the number `x` rotated `disp` bits to the right. The number `disp` may be any\nrepresentable integer.\n\nFor any valid displacement, the following identity holds:\n\n  assert(bit32.rrotate(x, disp) == bit32.rrotate(x, disp % 32))\n\nIn particular, negative displacements rotate to the left.\n\nNew in Lua 5.2. Deprecated in Lua 5.3.
rshift bit32.rshift(x, disp)\nReturns the number `x` shifted `disp` bits to the right. The number `disp` may be any\nrepresentable integer. Negative displacements shift to the left. In any direction, vacant\nbits are filled with zeros. In particular, displacements with absolute values higher than\n31 result in zero (all bits are shifted out).\n\nFor positive displacements, the following equality holds:\n\n  assert(bit32.rshift(b, disp) == math.floor(b % 2^32 / 2^disp))\n\nThis shift operation is what is called logical shift.\n\nNew in Lua 5.2. Deprecated in Lua 5.3.
running coroutine.running()\nReturns the running coroutine plus a boolean, true when the running coroutine is the main one.
searchers package.searchers (table)\nA table used by `require` to control how to find modules.\n\nEach entry in this table is a *searcher function*. When looking for a module, `require`\ncalls each of these searchers in ascending order, with the module name (the argument given\nto `require`) as its sole argument. If the searcher finds the module, it returns another\nfunction, the module *loader*, plus an extra value, a *loader data*, that will be passed\nto that loader and returned as a second result by `require`. If it cannot find the module,\nit returns a string explaining why (or nil if it has nothing to say).\n\nLua initializes this table with four functions.\n\nThe first searcher simply looks for a loader in the `package.preload` table.\n\nThe second searcher looks for a loader as a Lua library, using the path stored at\n`package.path`. The search is done as described in function `package.searchpath`.\n\nThe third searcher looks for a loader as a C library, using the path given by the variable\n`package.cpath`. Again, the search is done as described in function `package.searchpath`. For\ninstance, if the C path is the string\n\n  "./?.so;./?.dll;/usr/local/?/init.so"\n\nthe searcher for module `foo` will try to open the files `./foo.so`, `./foo.dll`, and\n`/usr/local/foo/init.so`, in that order. Once it finds a C library, this searcher first\nuses a dynamic link facility to link the application with the library. Then it tries to\nfind a C function inside the library to be used as the loader. The name of this C function\nis the string "`luaopen_`" concatenated with a copy of the module name where each dot\nis replaced by an underscore. Moreover, if the module name has a hyphen, its suffix after\n(and including) the first hyphen is removed. For instance, if the module name is `a.b.c-v2.1\n`, the function name will be `luaopen_a_b_c`.\n\nThe fourth searcher tries an *all-in-one loader*. It searches the C path for a library for\nthe root name of the given module. For instance, when requiring `a.b.c`, it will search for\na C library for `a`. If found, it looks into it for an open function for the submodule; in\nour example, that would be `luaopen_a_b_c`. With this facility, a package can pack several\nC submodules into one single library, with each submodule keeping its original open function.\n\nAll searchers except the first one (preload) return as the extra value the file path\nwhere the module was found, as returned by `package.searchpath`. The first searcher always\nreturns the string "`:preload:`".\n\nSearchers should raise no errors and have no side effects in Lua. (They may have side\neffects in C, for instance by linking the application with a library.)\n\nNew in Lua 5.2.
searchpath package.searchpath(name, path [, sep [, rep]])\nSearches for the given `name` in the given `path`.\n\nA path is a string containing a sequence of _templates_ separated by semicolons. For each\ntemplate, the function replaces each interrogation mark (if any) in the template with a copy\nof `name` wherein all occurrences of `sep` (a dot, by default) were replaced by `rep` (the\nsystem's directory separator, by default), and then tries to open the resulting file name.\nFor instance, if the path is the string\n\n  "./?.lua;./?.lc;/usr/local/?/init.lua"\n\nthe search for the name `foo.a` will try to open the files `./foo/a.lua`, `./foo/a.lc`, and\n`/usr/local/foo/a/init.lua`, in that order.\n\nReturns the resulting name of the first file that it can open in read mode (after closing\nthe file), or nil plus an error message if none succeeds. (This error message lists all file\nnames it tried to open.)\n\nNew in Lua 5.2.
seeall package.seeall(module)\nSets a metatable for `module` with its `__index` field referring to the global environment,\nso that this module inherits values from the global environment. To be used as an option to\nfunction `module`.\n\nDeprecated in Lua 5.2.
seek file:seek([whence [, offset]])\nSets and gets the file position, measured from the beginning of the file, to the position\ngiven by `offset` plus a base specified by the string `whence`, as follows:\n\n  * "set": base is position 0 (beginning of the file);\n  * "cur": base is current position;\n  * "end": base is end of file;\n\nIn case of success, function `seek` returns the final file position, measured in bytes from\nthe beginning of the file. If `seek` fails, it returns nil, plus a string describing the error.\n\nThe default value for `whence` is `"cur"`, and for `offset` is 0. Therefore, the\ncall `file:seek()` returns the current file position, without changing it; the call\n`file:seek("set")` sets the position to the beginning of the file (and returns 0); and the\ncall `file:seek("end")` sets the position to the end of the file, and returns its size.
select _G.select(index, ···)\nIf `index` is a number, returns all arguments after argument number `index`; a negative number\nindexes from the end (-1 is the last argument). Otherwise, `index` must be the string `"#"`,\nand `select` returns the total number of extra arguments it received.
setfenv _G.setfenv(f, table)\nSets the environment to be used by the given function. `f` can be a Lua function or a\nnumber that specifies the function at that stack level: Level 1 is the function calling\n`setfenv`. `setfenv` returns the given function. As a special case, when `f` is 0 `setfenv`\nchanges the environment of the running thread. In this case, `setfenv` returns no values.\n\nDeprecated in Lua 5.2.
setfenv debug.setfenv(object, table)\nSets the environment of the given `object` to the given `table`. Returns `object`.\n\nDeprecated in Lua 5.2.
sethook debug.sethook([thread, ] hook, mask [, count])\nSets the given function as the debug hook. The string `mask` and the number `count` describe\nwhen the hook will be called. The string mask may have any combination of the following\ncharacters, with the given meaning:\n\n  * "c": the hook is called every time Lua calls a function;\n  * "r": the hook is called every time Lua returns from a function;\n  * "l": the hook is called every time Lua enters a new line of code.\n\nMoreover, with a `count` different from zero, the hook is called also after every `count`\ninstructions.\n\nWhen called without arguments, `debug.sethook` turns off the hook.\n\nWhen the hook is called, its first parameter is a string describing the event that has\ntriggered its call: `"call"`, `"tail call"`, `"return"`, `"line"`, and `"count"`. For line\nevents, the hook also gets the new line number as its second parameter. Inside a hook, you\ncan call `getinfo` with level 2 to get more information about the running function. (Level\n0 is the `getinfo` function, and level 1 is the hook function.)
setlocal debug.setlocal([thread, ] level, local, value)\nThis function assigns the value `value` to the local variable with index `local` of the\nfunction at level `level` of the stack. The function returns nil if there is no local variable\nwith the given index, and raises an error when called with a `level` out of range. (You can\ncall `getinfo` to check whether the level is valid.) Otherwise, it returns the name of the\nlocal variable.\n\nSee `debug.getlocal` for more information about variable indices and names.
setlocale os.setlocale(locale [, category])\nSets the current locale of the program. `locale` is a system-dependent string specifying\na locale; `category` is an optional string describing which category to change: `"all"`,\n`"collate"`, `"ctype"`, `"monetary"`, `"numeric"`, or `"time"`; the default category is\n`"all"`. The function returns the name of the new locale, or nil if the request cannot\nbe honored.\n\nIf `locale` is the empty string, the current locale is set to an implementation-defined native\nlocale. If `locale` is the string "`C`", the current locale is set to the standard C locale.\n\nWhen called with nil as the first argument, this function only returns the name of the\ncurrent locale for the given category.\n\nThis function may not be thread safe because of its reliance on C function `setlocale`.
setmaxstack lpeg.setmaxstack(max)\nSets the maximum size for the backtrack stack used by LPeg to track calls and choices. Most\nwell-written patterns need little backtrack levels and therefore you seldom need to change\nthis maximum; but a few useful patterns may need more space. Before changing this maximum\nyou should try to rewrite your pattern to avoid the need for extra space.
setmetatable _G.setmetatable(table, metatable)\nSets the metatable for the given table. If `metatable` is nil, removes the metatable of the\ngiven table. If the original metatable has a `__metatable` field, raises an error.\n\nThis function returns `table`.\n\nTo change the metatable of other types from Lua code, you must use the debug library\n(see §6.10).
setmetatable debug.setmetatable(value, table)\nSets the metatable for the given `value` to the given `table` (which can be nil).
setmode lfs.setmode(file, mode)\nSets the writing mode for a file. The mode string can be either "binary" or "text". Returns\ntrue followed by the previous mode string for the file, or nil followed by an error string\nin case of errors. On non-Windows platforms, where the two modes are identical, setting\nthe mode has no effect, and the mode is always returned as binary.
setupvalue debug.setupvalue(f, up, value)\nThis function assigns the value `value` to the upvalue with index `up` of the function\n`f`. The function returns nil if there is no upvalue with the given index. Otherwise, it\nreturns the name of the upvalue.\n\nSee `debug.getupvalue` for more information about upvalues.
setuservalue debug.setuservalue(udata, value, n)\nSets the given `value` as the `n`-th user value associated to the given `udata`. `udata`\nmust be a full userdata.\n\nReturns `udata`, or nil if the userdata does not have that value.\n\nNew in Lua 5.2.
setvbuf file:setvbuf(mode [, size])\nSets the buffering mode for a file. There are three available modes:\n\n  * "no": no buffering\n  * "full": full buffering\n  * "line": line buffering\n\nFor the last two cases, `size` is a hint for the size of the buffer, in bytes. The default\nis an appropriate size.\n\nThe specific behavior of each mode is non portable; check the underlying ISO C function\n`setvbuf` in your platform for more details.
sin math.sin(x)\nReturns the sine of `x` (assumed to be in radians).
sinh math.sinh(x)\nReturns the hyperbolic sine of `x`.\n\nDeprecated in Lua 5.3.
sort table.sort(list [, comp])\nSorts the list elements in a given order, *in-place*, from `list[1]` to `list[#list]`. If\n`comp` is given, then it must be a function that receives two list elements and returns true\nwhen the first element must come before the second in the final order (so that, after the\nsort, `i < j` implies `not comp(list[j],list[i])` will be true after the sort). If `comp`\nis not given, then the standard Lua operator `<` is used instead.\n\nNote that the `comp` function must not define a string partial order over the elements in the\nlist; that is, it must be asymmetric and transitive. Otherwise, no valid sort may be possible.\n\nThe sort algorithm is not stable; that is, elements not comparable by the given order (e.g.,\nequal elements) may have their relative positions changed by the sort.
sqrt math.sqrt(x)\nReturns the square root of `x`. (You can also use the expression `x^0.5` to compute this value.)
status coroutine.status(co)\nReturns the status of the coroutine `co`, as a string: `"running"`, if the coroutine is\nrunning (that is, it is the one that called `status`); `"suspended"`, if the coroutine\nis suspended in a call to `yield`, or if it has not started running yet; `"normal"` if the\ncoroutine is active but not running (that is, it has resumed another coroutine); and `"dead"`\nif the coroutine has finished its body function, or if it has stopped with an error.
stderr io.stderr (file)\nStandard error.
stdin io.stdin (file)\nStandard in.
stdout io.stdout (file)\nStandard out.
string _G.string (module)\nLua string module.
sub string.sub(s, i [, j])\nReturns the substring of `s` that starts at `i` and continues until `j`; `i` and `j` can\nbe negative. If `j` is absent, then it is assumed to be equal to -1 (which is the same as\nthe string length). In particular, the call `string.sub(s,1,j)` returns a prefix of `s`\nwith length `j`, and `string.sub(s, -i)` returns a suffix of `s` with length `i`.\n\nIf, after the translation of negative indices, `i` is less than 1, it is corrected to 1. If `j`\nis greater than the string length, it is corrected to that length. If, after these corrections,\n`i` is greater than `j`, the function returns the empty string.
symlinkattributes lfs.symlinkattributes(filepath [, aname])\nIdentical to lfs.attributes except that it obtains information about the link itself (not\nthe file it refers to). It also adds a target field, containing the file name that the\nsymlink points to. On Windows this function does not yet support links, and is identical\nto lfs.attributes.
table _G.table (module)\nLua table module.
tan math.tan(x)\nReturns the tangent of `x` (assumed to be in radians).
tanh math.tanh(x)\nReturns the hyperbolic tangent of `x`.\n\nDeprecated in Lua 5.3.
time os.time([table])\nReturns the current time when called without arguments, or a time representing the date and\ntime specified by the given table. This table must have fields `year`, `month`, and `day`,\nand may have fields `hour` (default is 12), `min` (default is 0), `sec` (default is 0), and\n`isdst` (default is nil). For a description of these fields, see the `os.date` function.\n\nWhen the function is called, the values in these fields do not need to be inside their\nvalid ranges. For instance, if `sec` is -10, it means 10 seconds before the time specified\nby the other fields; if `hour` is 1000, it means 1000 hours after the time specified by the\nother fields.\n\nThe returned value is a number, whose meaning depends on your system. In POSIX, Windows,\nand some other systems, this number counts the number of seconds since some given start time\n(the "epoch"). In other systems, the meaning is not specified, and the number returned by\n`time` can be used only as an argument to `os.date` and `os.difftime`.\n\nWhen called with a table, `os.time` also normalizes all the fields documented in the `os.date`\nfunction, so that they represent the same time as before the call but with values inside\ntheir valid ranges.
tmpfile io.tmpfile()\nIn case of success, returns a handle for a temporary file. This file is opened in update\nmode and it is automatically removed when the program ends.
tmpname os.tmpname()\nReturns a string with a file name that can be used for a temporary file. The file must be\nexplicitly opened before its use and explicitly removed when no longer needed.\n\nOn POSIX systems, this function also creates a file with that name, to avoid security\nrisks. (Someone else might create the file with wrong permissions in the time between getting\nthe name and creating the file.) You still have to open the file to use it and to remove it\n(even if you do not use it).\n\nWhen possible, you may prefer to use `io.tmpfile`, which automatically removes the file when\nthe program ends.
tointeger math.tointeger(x)\nIf the value `x` is convertible to an integer, returns that integer. Otherwise, returns nil.\n\nNew in Lua 5.3.
tonumber _G.tonumber(e [, base])\nWhen called with no `base`, `tonumber` tries to convert its argument to a number. If the\nargument is already a number or a string convertible to a number, then `tonumber` returns\nthis number; otherwise, it returns nil.\n\nThe conversion of strings can result in integers or floats, according to the lexical\nconventions of Lua (see §3.1). The string may have leading and trailing spaces and a sign.\n\nWhen called with `base`, then `e` must be a string to be interpreted as an integer numeral\nin that base. The base may be any integer between 2 and 36, inclusive. In bases above 10,\nthe letter '`A`' (in either upper or lower case) represents 10, '`B`' represents 11, and so\nforth, with '`Z`' representing 35. If the string `e` is not a valid numeral in the given base,\nthe function returns nil
tostring _G.tostring(v)\nReceives a value of any type and converts it to a string in a human-readable format. Floats\nalways produce strings with some floating-point indication (either a decimal dot or an\nexponent).\n\nIf the metatable of `v` has a `__tostring` field, then `tostring` calls the corresponding\nvalue with `v` as argument, and uses the result of the call as its result. Otherwise, if the\nmetatable of `v` has a `__name` field with a string value, `tostring` may use that string\nin its final result.\n\nFor complete control of how numbers are converted, use `string.format`.
touch lfs.touch(filepath [, atime [, mtime]])\nSet access and modification times of a file. This function is a bind to utime function. The\nfirst argument is the filename, the second argument (atime) is the access time, and the\nthird argument (mtime) is the modification time. Both times are provided in seconds (which\nshould be generated with Lua standard function os.time). If the modification time is omitted,\nthe access time provided is used; if both times are omitted, the current time is used.\n\nReturns true in case of success or nil, an error message and a system-dependent error code\nin case of error.
traceback debug.traceback([thread, ] [message] [, level])\nIf `message` is present but is neither a string nor nil, this function returns `message`\nwithout further processing. Otherwise, it returns a string with a traceback of the call\nstack. The optional `message` string is appended at the beginning of the traceback. An optional\n`level` number tells at which level to start the traceback (default is 1, the function calling\n`traceback`).
type _G.type(v)\nReturns the type of its only argument, coded as a string. The possible results of this\nfunction are " `nil`" (a string, not the value nil), "`number`", "`string`", "`boolean`",\n"`table`", "`function`", "`thread`", and "`userdata`".
type io.type(obj)\nChecks whether `obj` is a valid file handle. Returns the string `"file"` if `obj` is an\nopen file handle, `"closed file"` if `obj` is a closed file handle, or nil if `obj` is not\na file handle.
type lpeg.type(value)\nIf the given value is a pattern, returns the string "pattern". Otherwise returns nil.
type math.type(x)\nReturns "integer" if `x` is an integer, "float" if it is a float, or nil if x is not a number.\n\nNew in Lua 5.3.
ult math.ult(m, n)\nReturns a boolean, true if integer `m` is below integer `n` when they are compared as\nunsigned integers.\n\nNew in Lua 5.3.
unlock lfs.unlock(filehandle[, start[, length]])\nUnlocks a file or a part of it. This function works on open files; the file handle should\nbe specified as the first argument. The optional arguments start and length can be used to\nspecify a starting point and its length; both should be numbers.\n\nReturns true if the operation was successful; in case of error, it returns nil plus an\nerror string.
unpack _G.unpack(list [, i [, j]])\nReturns the elements from the given table. This function is equivalent to return list[i],\nlist[i+1], ···, list[j] except that the above code can be written only for a fixed number\nof elements. By default, `i` is 1 and `j` is the length of the list, as defined by the length\noperator (see §2.5.5).\n\nDeprecated in Lua 5.2.
unpack string.unpack(fmt, s [, pos])\nReturns the values packed in string `s` (see `string.pack`) according to the format string\n`fmt` (see §6.4.2). An optional `pos` marks where to start reading in `s` (default is\n1). After the read values, this function also returns the index of the first unread byte in `s`.\n\nNew in Lua 5.3.
unpack table.unpack(list [, i [, j]])\nReturns the elements from the given list. This function is equivalent to\n\n  return list[i], list[i+1], ···, list[j]\n\nBy default, `i` is 1 and `j` is `#list`.\n\nNew in Lua 5.2.
upper string.upper(s)\nReceives a string and returns a copy of this string with all lowercase letters changed to\nuppercase. All other characters are left unchanged. The definition of what a lowercase letter\nis depends on the current locale.
upvalueid debug.upvalueid(f, n)\nReturns a unique identifier (as a light userdata) for the upvalue numbered `n` from the\ngiven function.\n\nThese unique identifiers allow a program to check whether different closures share upvalues. Lua\nclosures that share an upvalue (that is, that access a same external local variable) will\nreturn identical ids for those upvalue indices.\n\nNew in Lua 5.2.
upvaluejoin debug.upvaluejoin(f1, n1, f2, n2)\nMake the `n1`-th upvalue of the Lua closure `f1` refer to the `n2`-th upvalue of the Lua\nclosure `f2`.\n\nNew in Lua 5.2.
utf8 _G.utf8 (module)\nLua utf8 module.
version lpeg.version()\nReturns a string with the running version of LPeg.
warn _G.warn(msg1, ···)\nEmits a warning with a message composed by the concatenation of all its arguments (which\nshould be strings).\n\nBy convention, a one-piece message starting with '`@`' is intended to be a *control message*,\nwhich is a message to the warning system itself. In particular, the standard warning function in\nLua recognizes the control messages "`@off`", to stop the emission of warnings, and "`@on`",\nto (re)start the emission; it ignores unknown control messages.\n\nNew in Lua 5.4.
wrap coroutine.wrap(f)\nCreates a new coroutine, with body `f`; `f` must be a Lua function. Returns a function that\nresumes the coroutine each time it is called. Any arguments passed to this function behave as\nthe extra arguments to `resume`. The function returns the same values returned by `resume`,\nexcept the first boolean. In case of error, the function closes the coroutine and propagates\nthe error.
write file:write(···)\nWrites the value of each of its arguments to `file`. The arguments must be strings or numbers.\n\nIn case of success, this function returns `file`. Otherwise it returns nil plus a string\ndescribing the error.
write io.write(···)\nEquivalent to `io.output():write(···)`.
xor bit32.xor(...)\nReturns the bitwise "exclusive or" of its operands.\n\nNew in Lua 5.2. Deprecated in Lua 5.3.
xpcall _G.xpcall(f, msgh [, arg1, ···])\nThis function is similar to `pcall`, except that it sets a new message handler `msgh`.
yield coroutine.yield(···)\nSuspends the execution of the calling coroutine. Any arguments to `yield` are passed as\nextra results to `resume`.