lua_absindex lua_absindex(lua_State *L, int idx) [int]\nConverts the acceptable index `idx` into an absolute index (that is, one that\ndoes not depend on the stack top).\n
lua_Alloc (*lua_Alloc)(void *ud, void *ptr, size_t osize, size_t nsize) [void*]\nThe type of the memory-allocation function used by Lua states.  The allocator\nfunction must provide a functionality similar to `realloc`, but not exactly\nthe same.  Its arguments are `ud`, an opaque pointer passed to `lua_newstate`;\n`ptr`, a pointer to the block being allocated/reallocated/freed; `osize`,\nthe original size of the block or some code about what is being allocated;\n`nsize`, the new size of the block.\n\nWhen `ptr` is not `NULL`, `osize` is the size of the block pointed by `ptr`,\nthat is, the size given when it was allocated or reallocated.\n\nWhen `ptr` is `NULL`, `osize` encodes the kind of object that Lua is allocating.\n`osize` is any of `LUA_TSTRING`, `LUA_TTABLE`, `LUA_TFUNCTION`, `LUA_TUSERDATA`,\nor `LUA_TTHREAD` when (and only when) Lua is creating a new object of that type.\nWhen `osize` is some other value, Lua is allocating memory for something else.\n\nLua assumes the following behavior from the allocator function:\n\nWhen `nsize` is zero, the allocator should behave like `free` and return `NULL`.\n\nWhen `nsize` is not zero, the allocator should behave like `realloc`.  The\nallocator returns `NULL` if and only if it cannot fulfill the request.  Lua\nassumes that the allocator never fails when `osize >= nsize`.\n\nHere is a simple implementation for the allocator function.  It is used in\nthe auxiliary library by `luaL_newstate`.\n\n  static void *l_alloc (void *ud, void *ptr, size_t osize, size_t nsize) {\n    (void)ud;  (void)osize;  /* not used */\n    if (nsize == 0) {\n      free(ptr);\n      return NULL;\n    }\n    else\n      return realloc(ptr, nsize);\n  }\n\nNote that Standard C ensures that `free(NULL)` has no effect and that\n`realloc(NULL, size)` is equivalent to `malloc(size)`.  This code assumes that\n`realloc` does not fail when shrinking a block. (Although Standard C does not\nensure this behavior, it seems to be a safe assumption.)\n
lua_arith lua_arith(lua_State *L, int op) [void]\nPerforms an arithmetic operation over the two values (or one, in the case of\nnegation) at the top of the stack, with the value at the top being the second\noperand, pops these values, and pushes the result of the operation.  The\nfunction follows the semantics of the corresponding Lua operator (that is, it\nmay call metamethods).\n\nThe value of `op` must be one of the following constants:\n  * LUA_OPADD: performs addition (`+`)\n  * LUA_OPSUB: performs subtraction (`-`)\n  * LUA_OPMUL: performs multiplication (`*`)\n  * LUA_OPDIV: performs division (`/`)\n  * LUA_OPMOD: performs modulo (`%`)\n  * LUA_OPPOW: performs exponentiation (`^`)\n  * LUA_OPUNM: performs mathematical negation (unary `-`)\n
lua_atpanic lua_atpanic(lua_State *L, lua_CFunction panicf) [lua_CFunction]\nSets a new panic function and returns the old one (see §4.6).\n\nIf an error happens outside any protected environment, Lua calls a _panic\nfunction_ and then calls `abort`, thus exiting the host application.  Your panic\nfunction can avoid this exit by never returning (e.g., doing a long jump).\n\nThe panic function runs as if it were a message handler (see §2.3); in\nparticular, the error message is at the top of the stack.  However, there is no\nguarantees about stack space.  To push anything on the stack, the panic function\nshould first check the available space (see §4.2).\n
lua_call lua_call(lua_State *L, int nargs, int nresults) [void]\nCalls a function.\n\nTo call a function you must use the following protocol: first, the function\nto be called is pushed onto the stack; then, the arguments to the function\nare pushed in direct order; that is, the first argument is pushed first.\nFinally you call `lua_call`; `nargs` is the number of arguments that you\npushed onto the stack.  All arguments and the function value are popped from\nthe stack when the function is called.  The function results are pushed onto\nthe stack when the function returns.  The number of results is adjusted to\n`nresults`, unless `nresults` is `LUA_MULTRET`.  In this case, all results from\nthe function are pushed.  Lua takes care that the returned values fit into the\nstack space.  The function results are pushed onto the stack in direct order\n(the first result is pushed first), so that after the call the last result is on\nthe top of the stack.\n\nAny error inside the called function is propagated upwards (with a `longjmp`).\n\nThe following example shows how the host program can do the equivalent to\nthis Lua code:\n\n  a = f("how", t.x, 14)\n\nHere it is in C:\n\n  lua_getglobal(L, "f");                  /* function to be called */\n  lua_pushstring(L, "how");                        /* 1st argument */\n  lua_getglobal(L, "t");                    /* table to be indexed */\n  lua_getfield(L, -1, "x");        /* push result of t.x (2nd arg) */\n  lua_remove(L, -2);                  /* remove 't' from the stack */\n  lua_pushinteger(L, 14);                          /* 3rd argument */\n  lua_call(L, 3, 1);     /* call 'f' with 3 arguments and 1 result */\n  lua_setglobal(L, "a");                         /* set global 'a' */\n\nNote that the code above is "balanced": at its end, the stack is back to\nits original configuration.  This is considered good programming practice.\n
lua_callk lua_callk(lua_State *L, int nargs, int nresults, int ctx, lua_CFunction k) [void]\nThis function behaves exactly like `lua_call`, but allows the called function to\nyield (see §4.7).\n
lua_CFunction (*lua_CFunction)(lua_State *L) [int]\nType for C functions.\n\nIn order to communicate properly with Lua, a C function must use the\nfollowing protocol, which defines the way parameters and results are passed:\na C function receives its arguments from Lua in its stack in direct order\n(the first argument is pushed first).  So, when the function starts,\n`lua_gettop(L)` returns the number of arguments received by the function.\nThe first argument (if any) is at index 1 and its last argument is at index\n`lua_gettop(L)`.  To return values to Lua, a C function just pushes them onto\nthe stack, in direct order (the first result is pushed first), and returns\nthe number of results.  Any other value in the stack below the results will\nbe properly discarded by Lua.  Like a Lua function, a C function called by\nLua can also return many results.\n\nAs an example, the following function receives a variable number of numerical\narguments and returns their average and sum:\n\n  static int foo (lua_State *L) {\n    int n = lua_gettop(L);    /* number of arguments */\n    lua_Number sum = 0;\n    int i;\n    for (i = 1; i <= n; i++) {\n      if (!lua_isnumber(L, i)) {\n        lua_pushstring(L, "incorrect argument");\n        lua_error(L);\n      }\n      sum += lua_tonumber(L, i);\n    }\n    lua_pushnumber(L, sum/n);        /* first result */\n    lua_pushnumber(L, sum);         /* second result */\n    return 2;                   /* number of results */\n  }\n
lua_checkstack lua_checkstack(lua_State *L, int extra) [int]\nEnsures that there are at least `extra` free stack slots in the stack.\nIt returns false if it cannot fulfill the request, because it would cause the\nstack to be larger than a fixed maximum size (typically at least a few thousand\nelements) or because it cannot allocate memory for the new stack size.  This\nfunction never shrinks the stack; if the stack is already larger than the new\nsize, it is left unchanged.\n
lua_close lua_close(lua_State *L) [void]\nDestroys all objects in the given Lua state (calling the corresponding\ngarbage-collection metamethods, if any) and frees all dynamic memory used by\nthis state.  On several platforms, you may not need to call this function,\nbecause all resources are naturally released when the host program ends.\nOn the other hand, long-running programs that create multiple states, such as\ndaemons or web servers, might need to close states as soon as they are not\nneeded.\n
lua_compare lua_compare(lua_State *L, int index1, int index2, int op) [int]\nCompares two Lua values.\nReturns 1 if the value at acceptable index `index1` satisfies `op` when compared\nwith the value at acceptable index `index2`, following the semantics of the\ncorresponding Lua operator (that is, it may call metamethods).  Otherwise\nreturns 0.  Also returns 0 if any of the indices is non valid.\n\nThe value of `op` must be one of the following constants:\n  * LUA_OPEQ: compares for equality (`==`)\n  * LUA_OPLT: compares for less than (`<`)\n  * LUA_OPLE: compares for less or equal (`<=`)\n
lua_concat lua_concat(lua_State *L, int n) [void]\nConcatenates the `n` values at the top of the stack, pops them, and leaves\nthe result at the top.  If `n` is 1, the result is the single value on the\nstack (that is, the function does nothing); if `n` is 0, the result is the\nempty string.  Concatenation is performed following the usual semantics of\nLua (see §3.4.5).\n
lua_copy lua_copy(lua_State *L, int fromidx, int toidx) [void]\nMoves the element at the valid index `fromidx` into the valid index `toidx`\nwithout shifting any element (therefore replacing the value at that position).\n
lua_createtable lua_createtable(lua_State *L, int narr, int nrec) [void]\nCreates a new empty table and pushes it onto the stack.  Parameter `narr` is a\nhint for how many elements the table will have as a sequence; parameter `nrec`\nis a hint for how many other elements the table will have.  Lua may use these\nhints to preallocate memory for the new table. This pre-allocation is useful for\nperformance when you know in advance how many elements the table will have.\nOtherwise you can use the function `lua_newtable`.\n
lua_dump lua_dump(lua_State *L, lua_Writer writer, void *data) [int]\nDumps a function as a binary chunk.  Receives a Lua function on the top of\nthe stack and produces a binary chunk that, if loaded again, results in a\nfunction equivalent to the one dumped.  As it produces parts of the chunk,\n`lua_dump` calls function `writer` (see `lua_Writer`) with the given `data`\nto write them.\n\nThe value returned is the error code returned by the last call to the writer;\n0 means no errors.\n\nThis function does not pop the Lua function from the stack.\n
lua_error lua_error(lua_State *L) [int]\nGenerates a Lua error.  The error message (which can actually be a Lua value\nof any type) must be on the stack top.  This function does a long jump,\nand therefore never returns (see `luaL_error`).\n
lua_gc lua_gc(lua_State *L, int what, int data) [int]\nControls the garbage collector.\n\nThis function performs several tasks, according to the value of the parameter\n`what`:\n  * LUA_GCSTOP: stops the garbage collector.\n  * LUA_GCRESTART: restarts the garbage collector.\n  * LUA_GCCOLLECT: performs a full garbage-collection cycle.\n  * LUA_GCCOUNT: returns the current amount of memory (in Kbytes) in use by Lua.\n  * LUA_GCCOUNTB: returns the remainder of dividing the current amount of bytes\n    of memory in use by Lua by 1024.\n  * LUA_GCSTEP: performs an incremental step of garbage collection.\n    The step "size" is controlled by `data` (larger values mean more steps)\n    in a non-specified way.  If you want to control the step size you must\n    experimentally tune the value of `data`.  The function returns 1 if the\n    step finished a garbage-collection cycle.\n  * LUA_GCSETPAUSE: sets `data` as the new value for the _pause_ of the\n    collector (see §2.5).  The function returns the previous value of the\n    pause.\n  * LUA_GCSETSTEPMUL: sets `data` as the new value for the _step multiplier_ of\n    the collector (see §2.5).  The function returns the previous value of the\n    step multiplier.\n  * LUA_GCISRUNNING: returns a boolean that tells whether the collector is\n    running (i.e., not stopped).\n  * LUA_GCGEN: changes the collector to generational mode (see §2.5).\n  * LUA_GCINC: changes the collector to incremental mode.  This is the default\n    mode.\n\nFor more details about these options, see `collectgarbage`.\n
lua_getallocf lua_getallocf(lua_State *L, void **ud) [lua_Alloc]\nReturns the memory-allocation function of a given state.  If `ud` is not\n`NULL`, Lua stores in `*ud` the opaque pointer passed to `lua_newstate`.\n
lua_getctx lua_getctx(lua_State *L, int *ctx) [int]\nThis function is called by a continuation function (see §4.7) to retrieve the\nstatus of the thread and a context information.\n\nWhen called in the original function, `lua_getctx` always returns `LUA_OK` and\ndoes not change the value of its argument `ctx`.  When called inside a\ncontinuation function, `lua_getctx` returns `LUA_YIELD` and sets the value of\n`ctx` to be the context information (the value passed as the `ctx` argument to\nthe callee together with the continuation function).\n\nWhen the callee is `lua_pcallk`, Lua may also call its continuation function to\nhandle errors during the call.  That is, upon an error in the function called by\n`lua_pcallk`, Lua may not return to the original function but instead may call\nthe continuation function.  In that case, a call to `lua_getctx` will return the\nerror code (the value that would be returned by `lua_pcallk`); the value of\n`ctx` will be set to the context information, as in the case of a yield.\n
lua_getfield lua_getfield(lua_State *L, int index, const char *k) [void]\nPushes onto the stack the value `t[k]`, where `t` is the value at the given\nvalid index.  As in Lua, this function may trigger a metamethod for the\n"index" event (see §2.4).\n
lua_getglobal lua_getglobal(lua_State *L, const char *name) [void]\n\nPushes onto the stack the value of the global `name`.\n
lua_getmetatable lua_getmetatable(lua_State *L, int index) [int]\nPushes onto the stack the metatable of the value at the given acceptable index.\nIf the value does not have a metatable, the function returns 0 and pushes\nnothing on the stack.\n
lua_gettable lua_gettable(lua_State *L, int index) [void]\nPushes onto the stack the value `t[k]`, where `t` is the value at the given\nvalid index and `k` is the value at the top of the stack.\n\nThis function pops the key from the stack (putting the resulting value\nin its place).  As in Lua, this function may trigger a metamethod for the\n"index" event (see §2.4).\n
lua_gettop lua_gettop(lua_State *L) [int]\nReturns the index of the top element in the stack.  Because indices start\nat 1, this result is equal to the number of elements in the stack (and so\n0 means an empty stack).\n
lua_getuservalue lua_getuservalue(lua_State *L, int index) [void]\nPushes onto the stack the Lua value associated with the userdata at the given\nindex.  This Lua value must be a table or nil.\n
lua_insert lua_insert(lua_State *L, int index) [void]\nMoves the top element into the given valid index, shifting up the elements\nabove this index to open space.  Cannot be called with a pseudo-index,\nbecause a pseudo-index is not an actual stack position.\n
lua_Integer lua_Integer [ptrdiff_t]\nThe type used by the Lua API to represent signed integral values.\n\nBy default it is a `ptrdiff_t`, which is usually the largest signed integral\ntype the machine handles "comfortably".\n
lua_isboolean lua_isboolean(lua_State *L, int index) [int]\nReturns 1 if the value at the given acceptable index is a boolean, and 0\notherwise.\n
lua_iscfunction lua_iscfunction(lua_State *L, int index) [int]\nReturns 1 if the value at the given acceptable index is a C function,\nand 0 otherwise.\n
lua_isfunction lua_isfunction(lua_State *L, int index) [int]\nReturns 1 if the value at the given acceptable index is a function (either\nC or Lua), and 0 otherwise.\n
lua_islightuserdata lua_islightuserdata(lua_State *L, int index) [int]\n\nReturns 1 if the value at the given acceptable index is a light userdata,\nand 0 otherwise.\n
lua_isnil lua_isnil(lua_State *L, int index) [int]\nReturns 1 if the value at the given acceptable index is nil, and 0 otherwise.\n
lua_isnone lua_isnone(lua_State *L, int index) [int]\nReturns 1 if the given acceptable index is not valid (that is, it refers to\nan element outside the current stack), and 0 otherwise.\n
lua_isnoneornil lua_isnoneornil(lua_State *L, int index) [int]\nReturns 1 if the given acceptable index is not valid (that is, it refers to\nan element outside the current stack) or if the value at this index is nil,\nand 0 otherwise.\n
lua_isnumber lua_isnumber(lua_State *L, int index) [int]\nReturns 1 if the value at the given acceptable index is a number or a string\nconvertible to a number, and 0 otherwise.\n
lua_isstring lua_isstring (lua_State *L, int index) [int]\nReturns 1 if the value at the given acceptable index is a string or a number\n(which is always convertible to a string), and 0 otherwise.\n
lua_istable lua_istable(lua_State *L, int index) [int]\nReturns 1 if the value at the given acceptable index is a table, and 0\notherwise.\n
lua_isthread lua_isthread(lua_State *L, int index) [int]\nReturns 1 if the value at the given acceptable index is a thread, and\n0 otherwise.\n
lua_isuserdata lua_isuserdata(lua_State *L, int index) [int]\nReturns 1 if the value at the given acceptable index is a userdata (either\nfull or light), and 0 otherwise.\n
lua_len lua_len(lua_State *L, int index) [void]\nReturns the "length" of the value at the given acceptable index; it is\nequivalent to the '`#`' operator in Lua (see §3.4.6).  The result is pushed on\nthe stack.\n
lua_load lua_load(lua_State *L, lua_Reader reader, void *data, const char *source, const char *mode) [int]\nLoads a Lua chunk (without running it).  If there are no errors, `lua_load`\npushes the compiled chunk as a Lua function on top of the stack.  Otherwise, it\npushes an error message.\n\nThe return values of `lua_load` are:\n  * LUA_OK: no errors;\n  * LUA_ERRSYNTAX: syntax error during pre-compilation;\n  * LUA_ERRMEM: memory allocation error.\n  * LUA_ERRGCMM: error while running a `__gc` metamethod. (This error has no\n    relation with the chunk being loaded.  It is generated by the garbage\n    collector.)\n\nThe `lua_load` function uses a user-supplied `reader` function to read the chunk\n(see `lua_Reader`).  The `data` argument is an opaque value passed to the reader\nfunction.\n\nThe `source` argument gives a name to the chunk, which is used for error\nmessages and in debug information (see §4.9).\n\n`lua_load` automatically detects whether the chunk is text or binary and loads\nit accordingly (see program `luac`).  The string `mode` works as in function\n`load`, with the addition that a `NULL` value is equivalent to the string\n"`bt`".\n\nIf the resulting function has one upvalue, this upvalue is set to the value of\nthe global environment stored at index `LUA_RIDX_GLOBALS` in the registry\n(see §4.5).  When loading main chunks, this upvalue will be the `_ENV` variable\n(see §2.2).\n
lua_newstate lua_newstate(lua_Alloc f, void *ud) [lua_State*]\nCreates a new thread running in a new, independent state.  Returns `NULL` if\ncannot create the thread or the state (due to lack of memory).  The argument `f`\nis the allocator function; Lua does all memory allocation for this state through\nthis function.  The second argument, `ud`, is an opaque pointer that Lua passes\nto the allocator in every call.\n
lua_newtable lua_newtable(lua_State *L) [void]\nCreates a new empty table and pushes it onto the stack.  It is equivalent to\n`lua_createtable(L, 0, 0)`.\n
lua_newthread lua_newthread(lua_State *L) [lua_State*]\nCreates a new thread, pushes it on the stack, and returns a pointer to a\n`lua_State` that represents this new thread.  The new thread returned by this\nfunction shares with the original thread its global environment, but has an\nindependent execution stack.\n\nThere is no explicit function to close or to destroy a thread.  Threads are\nsubject to garbage collection, like any Lua object.\n
lua_newuserdata lua_newuserdata(lua_State *L, size_t size) [void*]\nThis function allocates a new block of memory with the given size, pushes onto\nthe stack a new full userdata with the block address, and returns this address.\nThe host program can freely use this memory.\n
lua_next lua_next(lua_State *L, int index) [int]\n\nPops a key from the stack, and pushes a key-value pair from the table at\nthe given index (the "next" pair after the given key).  If there are no more\nelements in the table, then `lua_next` returns 0 (and pushes nothing).\n\nA typical traversal looks like this:\n\n  /* table is in the stack at index 't' */\n  lua_pushnil(L);  /* first key */\n  while (lua_next(L, t) != 0) {\n    /* uses 'key' (at index -2) and 'value' (at index -1) */\n    printf("%s - %s\n",\n           lua_typename(L, lua_type(L, -2)),\n           lua_typename(L, lua_type(L, -1)));\n    /* removes 'value'; keeps 'key' for next iteration */\n    lua_pop(L, 1);\n  }\n\nWhile traversing a table, do not call `lua_tolstring` directly on a key, unless\nyou know that the key is actually a string.  Recall that `lua_tolstring` may\nchange the value at the given index; this confuses the next call to `lua_next`.\n\nSee function `next` for the caveats of modifying the table during its traversal.\n
lua_Number lua_Number [double]\nThe type of numbers in Lua.  By default, it is double, but that can be\nchanged in `luaconf.h`.  Through the configuration file you can change Lua to\noperate with another type for numbers (e.g., float or long).\n
lua_pcall lua_pcall(lua_State *L, int nargs, int nresults, int msgh) [int]\nCalls a function in protected mode.\n\nBoth `nargs` and `nresults` have the same meaning as in `lua_call`.  If there\nare no errors during the call, `lua_pcall` behaves exactly like `lua_call`.\nHowever, if there is any error,\n\n`lua_pcall` catches it, pushes a single value on the stack (the error message),\nand returns an error code.  Like `lua_call`, `lua_pcall` always removes the\nfunction and its arguments from the stack.\n\nIf `msgh` is 0, then the error message returned on the stack is exactly the\noriginal error message.  Otherwise, `msgh` is the stack index of a _message\nhandler_.  (In the current implementation, this index cannot be a pseudo-index.)\nIn case of runtime errors, this function will be called with the error message\nand its return value will be the message returned on the stack by `lua_pcall`.\n\nTypically, the message handler is used to add more debug information to the\nerror message, such as a stack traceback.  Such information cannot be gathered\nafter the return of `lua_pcall`, since by then the stack has unwound.\n\nThe `lua_pcall` function returns one of the following codes (defined in\n`lua.h`):\n  * LUA_OK (0): success.\n  * LUA_ERRRUN: a runtime error.\n  * LUA_ERRMEM: memory allocation error.  For such errors, Lua does not call the\n    message handler.\n  * LUA_ERRERR: error while running the message handler.\n  * LUA_ERRGCMM: error while running a `__gc` metamethod.  (This error typically\n    has no relation with the function being called.  It is generated by the\n    garbage collector.)\n
lua_pcallk lua_pcallk(lua_State *L, int nargs, int nresults, int errfunc, int ctx, lua_CFunction k) [int]\nThis function behaves exactly like `lua_pcall`, but allows the called function\nto yield (see §4.7).\n
lua_pop lua_pop(lua_State *L, int n) [void]\nPops `n` elements from the stack.\n
lua_pushboolean lua_pushboolean(lua_State *L, int b) [void]\nPushes a boolean value with value `b` onto the stack.\n
lua_pushcclosure lua_pushcclosure(lua_State *L, lua_CFunction fn, int n) [void]\nPushes a new C closure onto the stack.\n\nWhen a C function is created, it is possible to associate some values with it,\nthus creating a C closure (see §4.4); these values are then accessible to\nthe function whenever it is called.  To associate values with a C function,\nfirst these values should be pushed onto the stack (when there are multiple\nvalues, the first value is pushed first).  Then `lua_pushcclosure` is called to\ncreate and push the C function onto the stack, with the argument `n` telling\nhow many values should be associated with the function.  `lua_pushcclosure`\nalso pops these values from the stack.\n\nThe maximum value for `n` is 255.\n\nWhen `n` is zero, this function creates a _light C function_, which is just a\npointer to the C function.  In that case, it never throws a memory error.\n
lua_pushcfunction lua_pushcfunction(lua_State *L, lua_CFunction f) [void]\nPushes a C function onto the stack.  This function receives a pointer to a\nC function and pushes onto the stack a Lua value of type `function` that,\nwhen called, invokes the corresponding C function.\n\nAny function to be registered in Lua must follow the correct protocol to\nreceive its parameters and return its results (see `lua_CFunction`).\n\n`lua_pushcfunction` is defined as a macro:\n\n  #define lua_pushcfunction(L,f)  lua_pushcclosure(L,f,0)\nNote that `f` is used twice.\n
lua_pushfstring lua_pushfstring(lua_State *L, const char *fmt, ...) [const char*]\nPushes onto the stack a formatted string and returns a pointer to this string.\nIt is similar to the C function `sprintf`, but has some important differences:\n  * You do not have to allocate space for the result: the result is a\n    Lua string and Lua takes care of memory allocation (and deallocation,\n    through garbage collection).\n  * The conversion specifiers are quite restricted.  There are no flags,\n    widths, or precisions.  The conversion specifiers can only be '%%'\n    (inserts a '%' in the string), '%s' (inserts a zero-terminated string,\n    with no size restrictions), '%f' (inserts a `lua_Number`), '%p' (inserts\n    a pointer as a hexadecimal numeral), '%d' (inserts an `int`), and '%c'\n    (inserts an `int` as a byte).\n
lua_pushinteger lua_pushinteger(lua_State *L, lua_Integer n) [void]\nPushes a number with value `n` onto the stack.\n
lua_pushlightuserdata lua_pushlightuserdata(lua_State *L, void *p) [void]\nPushes a light userdata onto the stack.\n\nUserdata represent C values in Lua.  A _light userdata_ represents a pointer, a\n`void*`.  It is a value (like a number): you do not create it, it has no\nindividual metatable, and it is not collected (as it was never created).  A\nlight userdata is equal to "any" light userdata with the same C address.\n
lua_pushliteral lua_pushliteral(lua_State *L, const char *s) [const char*]\nThis macro is equivalent to `lua_pushlstring`, but can be used only when `s` is\na literal string.  It automatically provides the string length.\n
lua_pushlstring lua_pushlstring(lua_State *L, const char *s, size_t len) [const char*]\nPushes the string pointed to by `s` with size `len` onto the stack.  Lua makes\n(or reuses) an internal copy of the given string, so the memory at `s` can\nbe freed or reused immediately after the function returns.  The string can\ncontain any binary data, including embedded zeros.\n\nReturns a pointer to the internal copy of the string.\n
lua_pushnil lua_pushnil(lua_State *L) [void]\nPushes a nil value onto the stack.\n
lua_pushnumber lua_pushnumber(lua_State *L, lua_Number n) [void]\nPushes a number with value `n` onto the stack.\n
lua_pushstring lua_pushstring(lua_State *L, const char *s) [const char*]\nPushes the zero-terminated string pointed to by `s` onto the stack.  Lua makes\n(or reuses) an internal copy of the given string, so the memory at `s`\ncan be freed or reused immediately after the function returns.  The string\ncannot contain embedded zeros; it is assumed to end at the first zero.\n\nReturns a pointer to the internal copy of the string.\n\nIf `s` is `NULL`, pushes nil and returns `NULL`.\n
lua_pushthread lua_pushthread(lua_State *L) [int]\nPushes the thread represented by `L` onto the stack.  Returns 1 if this\nthread is the main thread of its state.\n
lua_pushvalue lua_pushvalue(lua_State *L, int index) [void]\nPushes a copy of the element at the given valid index onto the stack.\n
lua_pushvfstring lua_pushvfstring(lua_State *L, const char *fmt, va_list argp) [const char*]\nEquivalent to `lua_pushfstring`, except that it receives a `va_list` instead\nof a variable number of arguments.\n
lua_rawequal lua_rawequal(lua_State *L, int index1, int index2) [int]\nReturns 1 if the two values in acceptable indices `index1` and `index2` are\nprimitively equal (that is, without calling metamethods).  Otherwise returns 0.\nAlso returns 0 if any of the indices are non valid.\n
lua_rawget lua_rawget(lua_State *L, int index) [void]\nSimilar to `lua_gettable`, but does a raw access (i.e., without metamethods).\n
lua_rawgeti lua_rawgeti(lua_State *L, int index, int n) [void]\nPushes onto the stack the value `t[n]`, where `t` is the table at the given\nvalid index.  The access is raw; that is, it does not invoke metamethods.\n
lua_rawgetp lua_rawgetp(lua_State *L, int index, const void *p) [void]\nPushes onto the stack the value `t[k]`, where `t` is the table at the given\nvalid index and `k` is the pointer `p` represented as a light userdata.  The\naccess is raw; that is, it does not invoke metamethods.\n
lua_rawlen lua_rawlen(lua_State *L, int index) [size_t]\nReturns the raw "length" of the value at the given acceptable index: for\nstrings, this is the string length; for tables, this is the result of the length\noperator ('`#`') with no metamethods; for userdata, this is the size of the\nblock of memory allocated for the userdata; for other values, it is 0.\n
lua_rawset lua_rawset(lua_State *L, int index) [void]\nSimilar to `lua_settable`, but does a raw assignment (i.e., without\nmetamethods).\n
lua_rawseti lua_rawseti(lua_State *L, int index, int n) [void]\nDoes the equivalent of `t[n] = v`, where `t` is the table at the given valid\nindex and `v` is the value at the top of the stack.\n\nThis function pops the value from the stack.  The assignment is raw; that is, it\ndoes not invoke metamethods.\n
lua_rawsetp lua_rawsetp(lua_State *L, int index, const void *p) [void]\nDoes the equivalent of `t[k] = v`, where `t` is the table at the given valid\nindex, `k` is the pointer `p` represented as a light userdata, and `v` is the\nvalue at the top of the stack.\n\nThis function pops the value from the stack.  The assignment is raw; that is, it\ndoes not invoke metamethods.\n
lua_Reader (*lua_Reader)(lua_State *L, void *data, size_t *size) [const char*]\nThe reader function used by `lua_load`.  Every time it needs another piece of\nthe chunk, `lua_load` calls the reader, passing along its `data` parameter.\nThe reader must return a pointer to a block of memory with a new piece of\nthe chunk and set `size` to the block size.  The block must exist until the\nreader function is called again.  To signal the end of the chunk, the reader\nmust return `NULL` or set `size` to zero.  The reader function may return\npieces of any size greater than zero.\n
lua_register lua_register(lua_State *L, const char *name, lua_CFunction f) [void]\nSets the C function `f` as the new value of global `name`.  It is defined\nas a macro:\n\n  #define lua_register(L,n,f) (lua_pushcfunction(L, f), lua_setglobal(L, n))\n
lua_remove lua_remove(lua_State *L, int index) [void]\nRemoves the element at the given valid index, shifting down the elements\nabove this index to fill the gap.  Cannot be called with a pseudo-index,\nbecause a pseudo-index is not an actual stack position.\n
lua_replace lua_replace(lua_State *L, int index) [void]\nMoves the top element into the given position, without shifting any element\n(therefore replacing the value at the given position), and then pops the top\nelement.\n
lua_resume lua_resume(lua_State *L, lua_State *from, int nargs) [int]\nStarts and resumes a coroutine in a given thread.\n\nTo start a coroutine, you push onto the thread stack the main function plus any\narguments; then you call `lua_resume`, with `nargs` being the number of\narguments.  This call returns when the coroutine suspends or finishes its\nexecution.  When it returns, the stack contains all values passed to\n`lua_yield`, or all values returned by the body function.  `lua_resume` returns\n`LUA_YIELD` if the coroutine yields, `LUA_OK` if the coroutine finishes its\nexecution without errors, or an error code in case of errors (see `lua_pcall`).\n\nIn case of errors, the stack is not unwound, so you can use the debug API over\nit.  The error message is on the top of the stack.\n\nTo resume a coroutine, you put on its stack only the values to be passed as\nresults from `yield`, and then call `lua_resume`.\n
lua_setallocf lua_setallocf(lua_State *L, lua_Alloc f, void *ud) [void]\nChanges the allocator function of a given state to `f` with user data `ud`.\n
lua_setfield lua_setfield(lua_State *L, int index, const char *k) [void]\nDoes the equivalent to `t[k] = v`, where `t` is the value at the given valid\nindex and `v` is the value at the top of the stack.\n\nThis function pops the value from the stack.  As in Lua, this function may\ntrigger a metamethod for the "newindex" event (see §2.4).\n
lua_setglobal lua_setglobal(lua_State *L, const char *name) [void]\nPops a value from the stack and sets it as the new value of global `name`.\n
lua_setmetatable lua_setmetatable(lua_State *L, int index) [void]\nPops a table from the stack and sets it as the new metatable for the value\nat the given acceptable index.\n
lua_settable lua_settable(lua_State *L, int index) [void]\nDoes the equivalent to `t[k] = v`, where `t` is the value at the given\nvalid index,\n\n`v` is the value at the top of the stack, and `k` is the value just below\nthe top.\n\nThis function pops both the key and the value from the stack.  As in Lua,\nthis function may trigger a metamethod for the "newindex" event (see §2.4).\n
lua_settop lua_settop(lua_State *L, int index) [void]\nAccepts any acceptable index, or 0, and sets the stack top to this index.\nIf the new top is larger than the old one, then the new elements are filled\nwith <b>nil</b>.  If `index` is 0, then all stack elements are removed.\n
lua_setuservalue lua_setuservalue(lua_State *L, int index) [void]\nPops a table or nil from the stack and sets it as the new value associated to\nthe userdata at the given index.\n
lua_State lua_State [struct lua_State]\nAn opaque structure that points to a thread and indirectly (through the thread)\nto the whole state of a Lua interpreter.  The Lua library is fully reentrant: it\nhas no global variables.  All information about a state is accessible through\nthis structure.\n\nA pointer to this structure must be passed as the first argument to every\nfunction in the library, except to `lua_newstate`, which creates a Lua state\nfrom scratch.\n
lua_status lua_status(lua_State *L) [int]\nReturns the status of the thread `L`.\n\nThe status can be 0 (`LUA_OK`) for a normal thread, an error code if the thread\nfinished the execution of a `lua_resume` with an error, or `LUA_YIELD` if the\nthread is suspended.\n\nYou can only call functions in threads with status `LUA_OK`.  You can resume\nthreads with status `LUA_OK` (to start a new coroutine) or `LUA_YIELD` (to\nresume a coroutine).\n
lua_toboolean lua_toboolean(lua_State *L, int index) [int]\nConverts the Lua value at the given acceptable index to a C boolean value\n(0 or 1).  Like all tests in Lua, `lua_toboolean` returns true for any Lua value\ndifferent from false and nil; otherwise it returns false.  It also returns false\nwhen called with a non-valid index. (If you want to accept only actual boolean\nvalues, use `lua_isboolean` to test the value's type.)\n
lua_tocfunction lua_tocfunction(lua_State *L, int index) [lua_CFunction]\nConverts a value at the given acceptable index to a C function.  That value\nmust be a C function; otherwise, returns `NULL`.\n
lua_tointeger lua_tointeger(lua_State *L, int index) [lua_Integer]\nEquivalent to `lua_tointegerx` with `isnum` equal to `NULL`.\n
lua_tointegerx lua_tointegerx(lua_State *L, int index, int *isnum) [lua_Integer]\nConverts the Lua value at the given acceptable index to the signed integral\ntype `lua_Integer`.  The Lua value must be a number or a string convertible\nto a number (see §3.4.2); otherwise, `lua_tointegerx` returns 0.\n\nIf the number is not an integer, it is truncated in some non-specified way.\n\nIf `isnum` is not `NULL`, its referent is assigned a boolean value that\nindicates whether the operation succeeded.\n
lua_tolstring lua_tolstring(lua_State *L, int index, size_t *len) [const char*]\nConverts the Lua value at the given acceptable index to a C string.  If `len`\nis not `NULL`, it also sets `*len` with the string length.  The Lua value\nmust be a string or a number; otherwise, the function returns `NULL`.\nIf the value is a number, then `lua_tolstring` also _changes the actual\nvalue in the stack to a string_.  (This change confuses `lua_next` when\n`lua_tolstring` is applied to keys during a table traversal.)\n\n`lua_tolstring` returns a fully aligned pointer to a string inside the\nLua state.  This string always has a zero ('\0') after its last character\n(as in C), but can contain other zeros in its body.  Because Lua has garbage\ncollection, there is no guarantee that the pointer returned by `lua_tolstring`\nwill be valid after the corresponding value is removed from the stack.\n
lua_tonumber lua_tonumber(lua_State *L, int index) [lua_Number]\nEquivalent to `lua_tonumberx` with `isnum` equal to `NULL`.\n
lua_tonumberx lua_tonumberx(lua_State *L, int index, int *isnum) [lua_Number]\nConverts the Lua value at the given acceptable index to the C type `lua_Number`\n(see `lua_Number`).  The Lua value must be a number or a string convertible\nto a number (see §3.4.2); otherwise, `lua_tonumberx` returns 0.\n\nIf `isnum` is not `NULL`, its referent is assigned a boolean value that\nindicates whether the operation succeeded.\n
lua_topointer lua_topointer(lua_State *L, int index) [const void*]\nConverts the value at the given acceptable index to a generic C pointer\n(`void*`).  The value can be a userdata, a table, a thread, or a function;\notherwise, `lua_topointer` returns `NULL`.  Different objects will give\ndifferent pointers.  There is no way to convert the pointer back to its\noriginal value.\n\nTypically this function is used only for debug information.\n
lua_tostring lua_tostring(lua_State *L, int index) [const char*]\nEquivalent to `lua_tolstring` with `len` equal to `NULL`.\n
lua_tothread lua_tothread(lua_State *L, int index) [lua_State*]\nConverts the value at the given acceptable index to a Lua thread (represented\nas `lua_State*`).  This value must be a thread; otherwise, the function\nreturns `NULL`.\n
lua_tounsigned lua_tounsigned(lua_State *L, int index) [lua_Unsigned]\nEquivalent to `lua_tounsignedx` with `isnum` equal to `NULL`.\n
lua_tounsignedx lua_tounsignedx(lua_State *L, int index, int *isnum) [lua_Unsigned]\nConverts the Lua value at the given acceptable index to the unsigned integral\ntype `lua_Unsigned`.  The Lua value must be a number or a string convertible to\na number (see §3.4.2); otherwise, `lua_tounsignedx` returns 0.\n\nIf the number is not an integer, it is truncated in some non-specified way.\nIf the number is outside the range of representable values, it is normalized to\nthe remainder of its division by one more than the maximum representable value.\n\nIf `isnum` is not `NULL`, its referent is assigned a boolean value that\nindicates whether the operation succeeded.\n
lua_touserdata lua_touserdata(lua_State *L, int index) [void*]\nIf the value at the given acceptable index is a full userdata, returns\nits block address.  If the value is a light userdata, returns its pointer.\nOtherwise, returns `NULL`.\n
lua_type lua_type(lua_State *L, int index) [int]\nReturns the type of the value in the given acceptable index, or `LUA_TNONE` for\na non-valid index.\n\nThe types returned by `lua_type` are coded by the following constants defined in\n`lua.h`: `LUA_TNIL`, `LUA_TNUMBER`, `LUA_TBOOLEAN`, `LUA_TSTRING`, `LUA_TTABLE`,\n`LUA_TFUNCTION`, `LUA_TUSERDATA`, `LUA_TTHREAD`, and `LUA_TLIGHTUSERDATA`.\n
lua_typename lua_typename(lua_State *L, int tp) [const char*]\nReturns the name of the type encoded by the value `tp`, which must be one\nthe values returned by `lua_type`.\n
lua_Unsigned lua_Unsigned [typedef unsigned long lua_Unsigned]\nThe type used by the Lua API to represent unsigned integral values.  It must\nhave at least 32 bits.\n\nBy default it is an `unsigned int` or an `unsigned long`, whichever can hold\n32-bit values.\n
lua_version lua_version(lua_State *L) [const lua_Number]\nReturns the address of the version number stored in the Lua core.  When called\nwith a valid `lua_State`, returns the address of the version used to create that\nstate.  When called with `NULL`, returns the address of the version running the\ncall.\n
lua_Writer (*lua_Writer)(lua_State *L, const void* p, size_t sz, void* ud) [int]\nThe type of the writer function used by `lua_dump`.  Every time it produces\nanother piece of chunk, `lua_dump` calls the writer, passing along the buffer\nto be written (`p`), its size (`sz`), and the `data` parameter supplied to\n`lua_dump`.\n\nThe writer returns an error code: 0 means no errors; any other value means\nan error and stops `lua_dump` from calling the writer again.\n
lua_xmove lua_xmove(lua_State *from, lua_State *to, int n) [void]\nExchange values between different threads of the same state.\n\nThis function pops `n` values from the stack `from`, and pushes them onto\nthe stack `to`.\n
lua_yield lua_yield(lua_State *L, int nresults) [int]\nThis function is equivalent to `lua_yieldk`, but it has no continuation\n(see §4.7).  Therefore, when the thread resumes, it returns to the function that\ncalled the function calling `lua_yield`.\n
lua_yieldk lua_yieldk(lua_State *L, int nresults, int ctx, lua_CFunction k) [int]\nYields a coroutine.\n\nThis function should only be called as the return expression of a C function,\nas follows:\n\n  return lua_yieldk (L, n, i, k);\n\nWhen a C function calls `lua_yieldk` in that way, the running coroutine\nsuspends its execution, and the call to `lua_resume` that started this\ncoroutine returns.  The parameter `nresults` is the number of values from\nthe stack that are passed as results to `lua_resume`.\n\nWhen the coroutine is resumed again, Lua calls the given continuation function\n`k` to continue the execution of the C function that yielded (see §4.7).  This\ncontinuation function receives the same stack from the previous function, with\nthe results removed and replaced by the arguments passed to `lua_resume`.\nMoreover, the continuation function may access the value `ctx` by calling\n`lua_getctx`.\n
lua_Debug lua_Debug [struct]\ntypedef struct lua_Debug {\n  int event;\n  const char *name;           /* (n) */\n  const char *namewhat;       /* (n) */\n  const char *what;           /* (S) */\n  const char *source;         /* (S) */\n  int currentline;            /* (l) */\n  int linedefined;            /* (S) */\n  int lastlinedefined;        /* (S) */\n  unsigned char nups;         /* (u) number of upvalues */\n  unsigned char nparams;      /* (u) number of parameters */\n  char isvararg;              /* (u) */\n  char istailcall;            /* (t) */\n  char short_src[LUA_IDSIZE]; /* (S) */\n  /* private part */\n  _other fields_\n} lua_Debug;\n\nA structure used to carry different pieces of information about a function or an\nactivation record.  `lua_getstack` fills only the private part of this\nstructure, for later use.  To fill the other fields of `lua_Debug` with useful\ninformation, call `lua_getinfo`.\n\nThe fields of `lua_Debug` have the following meaning:\n  * source: the source of the chunk that created the function. If `source`\n    starts with a '`@`', it means that the function was defined in a file where\n    the file name follows the '`@`'.  If `source` starts with a '`=`', the\n    remainder of its contents describe the source in a user-dependent manner.\n    Otherwise, the function was defined in a string where `source` is that\n    string.\n  * short_src: a "printable" version of `source`, to be used in error messages.\n  * linedefined: the line number where the definition of the function starts.\n  * lastlinedefined: the line number where the definition of the function ends.\n  * what: the string "Lua" if the function is a Lua function, "C" if it is a\n    C function, "main" if it is the main part of a chunk.\n  * currentline: the current line where the given function is executing.\n    When no line information is available, `currentline` is set to -1.\n  * name: a reasonable name for the given function.  Because functions in Lua\n    are first-class values, they do not have a fixed name: some functions\n    can be the value of multiple global variables, while others can be\n    stored only in a table field.  The `lua_getinfo` function checks how the\n    function was called to find a suitable name.  If it cannot find a name,\n    then `name` is set to `NULL`.\n  * namewhat: explains the `name` field.  The value of `namewhat` can be\n    "global", "local", "method", "field", "upvalue", or "" (the empty string),\n    according to how the function was called.  (Lua uses the empty string\n    when no other option seems to apply.)\n  * istailcall: true if this function invocation was called by a tail call.  In\n    this case, the caller of this level is not in the stack.\n  * nups: the number of upvalues of the function.\n  * nparams: the number of fixed parameters of the function (always 0 for C\n    functions).\n  * isvararg: true if the function is a vararg function (always true for C\n    functions).\n
lua_gethook lua_gethook(lua_State *L) [lua_Hook]\nReturns the current hook function.\n
lua_gethookcount lua_gethookcount(lua_State *L) [int]\nReturns the current hook count.\n
lua_gethookmask lua_gethookmask(lua_State *L) [int]\nReturns the current hook mask.\n
lua_getinfo lua_getinfo(lua_State *L, const char *what, lua_Debug *ar) [int]\nGets information about a specific function or function invocation.\n\nTo get information about a function invocation, the parameter `ar` must be a\nvalid activation record that was filled by a previous call to `lua_getstack`\nor given as argument to a hook (see `lua_Hook`).\n\nTo get information about a function you push it onto the stack and start the\n`what` string with the character '>'.  (In that case, `lua_getinfo` pops the\nfunction from the top of the stack.)  For instance, to know in which line a\nfunction `f` was defined, you can write the following code:\n\n  lua_Debug ar;\n  lua_getglobal(L, "f");  /* get global 'f' */\n  lua_getinfo(L, ">S", &ar);\n  printf("%d\n", ar.linedefined);\n\nEach character in the string `what` selects some fields of the structure\n`ar` to be filled or a value to be pushed on the stack:\n  * 'n': fills in the field `name` and `namewhat`;\n  * 'S': fills in the fields `source`, `short_src`, `linedefined`,\n    `lastlinedefined`, and `what`;\n  * 'l': fills in the field `currentline`;\n  * 't': fills in the field `istailcall`;\n  * 'u': fills in the fields `nups`, `nparams`, and `isvararg`;\n  * 'f': pushes onto the stack the function that is running at the given level;\n  * 'L': pushes onto the stack a table whose indices are the numbers of the\n    lines that are valid on the function.  (A _valid line_ is a line with\n    some associated code, that is, a line where you can put a break point.\n    Non-valid lines include empty lines and comments.)\n\nThis function returns 0 on error (for instance, an invalid option in `what`).\n
lua_getlocal lua_getlocal(lua_State *L, lua_Debug *ar, int n) [const char*]\nGets information about a local variable of a given activation record or a given\nfunction.\n\nIn the first case, the parameter `ar` must be a valid activation record that was\nfilled by a previous call to `lua_getstack` or given as argument to a hook (see\n`lua_Hook`). The index `n` selects which local variable to inspect; see\n`debug.getlocal` for details about variable indices and names.\n\n`lua_getlocal` pushes the variable's value onto the stack and returns its name.\n\nIn the second case, `ar` should be `NULL` and the function to be inspected must\nbe at the top of the stack.  In this case, only parameters of Lua functions are\nvisible (as there is no information about what variables are active) and no\nvalues are pushed onto the stack.\n\nReturns `NULL` (and pushes nothing) when the index is greater than the number of\nactive local variables.\n
lua_getstack lua_getstack(lua_State *L, int level, lua_Debug *ar) [int]\nGets information about the interpreter runtime stack.\n\nThis function fills parts of a `lua_Debug` structure with an identification of\nthe _activation record_ of the function executing at a given level.  Level 0\nis the current running function, whereas level _n+1_ is the function that\nhas called level _n_ (except for tail calls, which do not count on the stack).\nWhen there are no errors, `lua_getstack` returns 1; when called with a level\ngreater than the stack depth, it returns 0.\n
lua_getupvalue lua_getupvalue(lua_State *L, int funcindex, int n) [const char*]\nGets information about a closure's upvalue.  (For Lua functions, upvalues are\nthe external local variables that the function uses, and that are consequently\nincluded in its closure.)  `lua_getupvalue` gets the index `n` of an upvalue,\npushes the upvalue's value onto the stack, and returns its name.`funcindex`\npoints to the closure in the stack.  (Upvalues have no particular order,\nas they are active through the whole function.  So, they are numbered in an\narbitrary order.)\n\nReturns `NULL` (and pushes nothing) when the index is greater than the\nnumber of upvalues.  For C functions, this function uses the empty string\n"" as a name for all upvalues.\n
lua_Hook (*lua_Hook)(lua_State *L, lua_Debug *ar) [void]\nType for debugging hook functions.\n\nWhenever a hook is called, its `ar` argument has its field `event` set to the\nspecific event that triggered the hook.  Lua identifies these events with\nthe following constants: `LUA_HOOKCALL`, `LUA_HOOKRET`, `LUA_HOOKTAILCALL`,\n`LUA_HOOKLINE`, and `LUA_HOOKCOUNT`.  Moreover, for line events, the\nfield `currentline` is also set.  To get the value of any other field in\n`ar`, the hook must call `lua_getinfo`.\n\nFor call events, `event` can be `LUA_HOOKCALL`, the normal value, or\n`LUA_HOOKTAILCALL`, for a tail call; in this case, there will be no\ncorresponding return event.\n\nWhile Lua is running a hook, it disables other calls to hooks.  Therefore,\nif a hook calls back Lua to execute a function or a chunk, this execution\noccurs without any calls to hooks.\n\nHook functions cannot have continuations, that is, they cannot call\n`lua_yieldk`, `lua_pcallk`, or `lua_callk` with a non-null `k`.\n\nHook functions can yield under the following conditions: Only count and line\nevents can yield and they cannot yield any value; to yield a hook function must\nfinish its execution calling `lua_yield` with `nresults` equal to zero.\n
lua_sethook lua_sethook(lua_State *L, lua_Hook f, int mask, int count) [int]\nSets the debugging hook function.\n\nArgument `f` is the hook function.\n\n`mask` specifies on which events the hook will be called: it is formed by a\nbitwise or of the constants `LUA_MASKCALL`, `LUA_MASKRET`, `LUA_MASKLINE`,\nand `LUA_MASKCOUNT`.  The `count` argument is only meaningful when the mask\nincludes `LUA_MASKCOUNT`.  For each event, the hook is called as explained\nbelow:\n  * The call hook: is called when the interpreter calls a function.  The hook is\n    called just after Lua enters the new function, before the function gets\n    its arguments.\n  * The return hook: is called when the interpreter returns from a function.\n    The hook is called just before Lua leaves the function.  There is no\n    standard way to access the values to be returned by the function.\n  * The line hook: is called when the interpreter is about to start the\n    execution of a new line of code, or when it jumps back in the code (even\n    to the same line).  (This event only happens while Lua is executing a\n    Lua function.)\n  * The count hook: is called after the interpreter executes every `count`\n    instructions.  (This event only happens while Lua is executing a Lua\n    function.)\n\nA hook is disabled by setting `mask` to zero.\n
lua_setlocal lua_setlocal(lua_State *L, lua_Debug *ar, int n) [const char*]\nSets the value of a local variable of a given activation record.  Parameters\n`ar` and `n` are as in `lua_getlocal` (see `lua_getlocal`).  `lua_setlocal`\nassigns the value at the top of the stack to the variable and returns its name.\nIt also pops the value from the stack.\n\nReturns `NULL` (and pops nothing) when the index is greater than the number\nof active local variables.\n
lua_setupvalue lua_setupvalue(lua_State *L, int funcindex, int n) [const char*]\nSets the value of a closure's upvalue.  It assigns the value at the top of\nthe stack to the upvalue and returns its name.  It also pops the value from\nthe stack.  Parameters `funcindex` and `n` are as in the `lua_getupvalue`\n(see `lua_getupvalue`).\n\nReturns `NULL` (and pops nothing) when the index is greater than the number\nof upvalues.\n
lua_upvalueid lua_upvalueid(lua_State *L, int funcindex, int n) [void*]\nReturns an unique identifier for the upvalue numbered `n` from the closure at\nindex `funcindex`.  Parameters `funcindex` and `n` are as in the\n`lua_getupvalue` (see `lua_getupvalue`) (but `n` cannot be greater than the\nnumber of upvalues).\n\nThese unique identifiers allow a program to check whether different closures\nshare upvalues.  Lua closures that share an upvalue (that is, that access a same\nexternal local variable) will return identical ids for those upvalue indices.\n
lua_upvaluejoin lua_upvaluejoin(lua_State *L, int funcindex1, int n1, int funcindex2, int n2) [void]\nMake the `n1`-th upvalue of the Lua closure at index `funcindex1` refer to the\n`n2`-th upvalue of the Lua closure at index `funcindex2`.\n
luaL_addchar luaL_addchar(luaL_Buffer *B, char c) [void]\nAdds the byte `c` to the buffer `B` (see `luaL_Buffer`).\n
luaL_addlstring luaL_addlstring(luaL_Buffer *B, const char *s, size_t l) [void]\nAdds the string pointed to by `s` with length `l` to the buffer `B` (see\n`luaL_Buffer`).  The string can contain embedded zeros.\n
luaL_addsize luaL_addsize(luaL_Buffer *B, size_t n) [void]\nAdds to the buffer `B` (see `luaL_Buffer`) a string of length `n` previously\ncopied to the buffer area (see `luaL_prepbuffer`).\n
luaL_addstring luaL_addstring(luaL_Buffer *B, const char *s) [void]\nAdds the zero-terminated string pointed to by `s` to the buffer `B` (see\n`luaL_Buffer`).  The string cannot contain embedded zeros.\n
luaL_addvalue luaL_addvalue(luaL_Buffer *B) [void]\nAdds the value at the top of the stack to the buffer `B` (see `luaL_Buffer`).\nPops the value.\n\nThis is the only function on string buffers that can (and must) be called with\nan extra element on the stack, which is the value to be added to the buffer.\n
luaL_argcheck luaL_argcheck(lua_State *L, int cond, int arg, const char *extramsg) [void]\nChecks whether `cond` is true.  If not, raises an error with a standard message.\n
luaL_argerror luaL_argerror(lua_State *L, int arg, const char *extramsg) [int]\nRaises an error with a standard message that includes `extramsg` as a comment.\n\nThis function never returns, but it is an idiom to use it in C functions as\n`return luaL_argerror(args)`.\n
luaL_Buffer luaL_Buffer [struct]\nType for a _string buffer_.\n\nA string buffer allows C code to build Lua strings piecemeal.  Its pattern\nof use is as follows:\n  * First declare a variable `b` of type `luaL_Buffer`.\n  * Then initialize it with a call `luaL_buffinit(L, &b)`.\n  * Then add string pieces to the buffer calling any of the `luaL_add*`\n    functions.\n  * Finish by calling `luaL_pushresult(&b)`.  This call leaves the final string\n    on the top of the stack.\n\nIf you know beforehand the total size of the resulting string, you can use the\nbuffer like this:\n  * First declare a variable `b` of type `luaL_Buffer`.\n  * Then initialize it and preallocate a space of size `sz` with a call\n    `luaL_buffinitsize(L, &b, sz)`.\n  * Then copy the string into that space.\n  * Finish by calling `luaL_pushresultsize(&b, sz)`, where `sz` is the total\n    size of the resulting string copied into that space.\n\nDuring its normal operation, a string buffer uses a variable number of\nstack slots.  So, while using a buffer, you cannot assume that you know\nwhere the top of the stack is.  You can use the stack between successive\ncalls to buffer operations as long as that use is balanced; that is, when you\ncall a buffer operation, the stack is at the same level it was immediately\nafter the previous buffer operation.  (The only exception to this rule is\n`luaL_addvalue`.)  After calling `luaL_pushresult` the stack is back to its\nlevel when the buffer was initialized, plus the final string on its top.\n
luaL_buffinit luaL_buffinit(lua_State *L, luaL_Buffer *B) [void]\nInitializes a buffer `B`.  This function does not allocate any space; the\nbuffer must be declared as a variable (see `luaL_Buffer`).\n
luaL_buffinitsize luaL_buffinitsize(lua_State *L, luaL_Buffer *B, size_t sz) [char*]\nEquivalent to the sequence `luaL_buffinit`, `luaL_prepbuffsize`.\n
luaL_callmeta luaL_callmeta(lua_State *L, int obj, const char *e) [int]\nCalls a metamethod.\n\nIf the object at index `obj` has a metatable and this metatable has a field\n`e`, this function calls this field passing the object as its only argument.\nIn this case this function returns true and pushes onto the stack the value\nreturned by the call.  If there is no metatable or no metamethod, this function\nreturns false (without pushing any value on the stack).\n
luaL_checkany luaL_checkany(lua_State *L, int arg) [void]\nChecks whether the function has an argument of any type (including nil)\nat position `arg`.\n
luaL_checkint luaL_checkint(lua_State *L, int arg) [int]\nChecks whether the function argument `arg` is a number and returns this number\ncast to an `int`.\n
luaL_checkinteger luaL_checkinteger(lua_State *L, int arg) [lua_Integer]\nChecks whether the function argument `arg` is a number and returns this number\ncast to a `lua_Integer`.\n
luaL_checklong luaL_checklong(lua_State *L, int arg) [long]\nChecks whether the function argument `arg` is a number and returns this number\ncast to a `long`.\n
luaL_checklstring luaL_checklstring(lua_State *L, int arg, size_t *l) [const char*]\nChecks whether the function argument `arg` is a string and returns this string;\nif `l` is not `NULL` fills `*l` with the string's length.\n\nThis function uses `lua_tolstring` to get its result, so all conversions\nand caveats of that function apply here.\n
luaL_checknumber luaL_checknumber(lua_State *L, int arg) [lua_Number]\nChecks whether the function argument `arg` is a number and returns this number.\n
luaL_checkoption luaL_checkoption(lua_State *L, int arg, const char *def, const char *const lst[]) [int]\nChecks whether the function argument `arg` is a string and searches for this\nstring in the array `lst` (which must be NULL-terminated).  Returns the index\nin the array where the string was found.  Raises an error if the argument\nis not a string or if the string cannot be found.\n\nIf `def` is not `NULL`, the function uses `def` as a default value when\nthere is no argument `arg` or when this argument is nil.\n\nThis is a useful function for mapping strings to C enums.  (The usual\nconvention in Lua libraries is to use strings instead of numbers to select\noptions.)\n
luaL_checkstack luaL_checkstack(lua_State *L, int sz, const char *msg) [void]\nGrows the stack size to `top + sz` elements, raising an error if the stack\ncannot grow to that size.  `msg` is an additional text to go into the error\nmessage (or `NULL` for no additional text).\n
luaL_checkstring luaL_checkstring(lua_State *L, int arg) [const char*]\nChecks whether the function argument `arg` is a string and returns this string.\n\nThis function uses `lua_tolstring` to get its result, so all conversions\nand caveats of that function apply here.\n
luaL_checktype luaL_checktype(lua_State *L, int arg, int t) [void]\nChecks whether the function argument `arg` has type `t`.  See `lua_type` for\nthe encoding of types for `t`.\n
luaL_checkudata luaL_checkudata(lua_State *L, int arg, const char *tname) [void*]\nChecks whether the function argument `arg` is a userdata of the type `tname`\n(see `luaL_newmetatable`) and returns the userdata address (see\n`lua_touserdata`).\n
luaL_checkunsigned luaL_checkunsigned(lua_State *L, int arg) [lua_Unsigned]\nChecks whether the function argument `arg` is a number and returns this number\ncast to a `lua_Unsigned`.\n
luaL_checkversion luaL_checkversion(lua_State *L) [void]\nChecks whether the core running the call, the core that created the Lua state,\nand the code making the call are all using the same version of Lua.  Also checks\nwhether the core running the call and the core that created the Lua state are\nusing the same address space.\n
luaL_dofile luaL_dofile(lua_State *L, const char *filename) [int]\nLoads and runs the given file.  It is defined as the following macro:\n\n  (luaL_loadfile(L, filename) || lua_pcall(L, 0, LUA_MULTRET, 0))\n\nIt returns false if there are no errors or true in case of errors.\n
luaL_dostring luaL_dostring(lua_State *L, const char *str) [int]\nLoads and runs the given string.  It is defined as the following macro:\n\n  (luaL_loadstring(L, str) || lua_pcall(L, 0, LUA_MULTRET, 0))\n\nIt returns false if there are no errors or true in case of errors.\n
luaL_error luaL_error(lua_State *L, const char *fmt, ...) [int]\nRaises an error.  The error message format is given by `fmt` plus any extra\narguments, following the same rules of `lua_pushfstring`.  It also adds at\nthe beginning of the message the file name and the line number where the\nerror occurred, if this information is available.\n\nThis function never returns, but it is an idiom to use it in C functions as\n`return luaL_error(args)`.\n
luaL_execresult luaL_execresult(lua_State *L, int stat) [int]\nThis function produces the return values for process-related functions in the\nstandard library (`os.execute` and `io.close`).\n
luaL_fileresult luaL_fileresult(lua_State *L, int stat, const char *fname) [int]\nThis function produces the return values for file-related functions in the\nstandard library (`io.open`, `os.rename`, `file:seek`, etc.).\n
luaL_getmetafield luaL_getmetafield(lua_State *L, int obj, const char *e) [int]\nPushes onto the stack the field `e` from the metatable of the object at index\n`obj`.  If the object does not have a metatable, or if the metatable does\nnot have this field, returns false and pushes nothing.\n
luaL_getmetatable luaL_getmetatable(lua_State *L, const char *tname) [void]\nPushes onto the stack the metatable associated with name `tname` in the\nregistry (see `luaL_newmetatable`).\n
luaL_getsubtable luaL_getsubtable(lua_State *L, int idx, const char *fname) [int]\nEnsures that the value `t[fname]`, where `t` is the value at the valid index\n`idx`, is a table, and pushes that table onto the stack.  Returns true if it\nfinds a previous table there and false if it creates a new table.\n
luaL_gsub luaL_gsub(lua_State *L, const char *s, const char *p, const char *r) [const char*]\nCreates a copy of string `s` by replacing any occurrence of the string `p`\nwith the string `r`.  Pushes the resulting string on the stack and returns it.\n
luaL_len luaL_len(lua_State *L, int index) [int]\nReturns the "length" of the value at the given acceptable index as a number; it\nis equivalent to the '`#`' operator in Lua (see §3.4.6).  Raises an error if the\nresult of the operation is not a number.  (This case only can happen through\nmetamethods.)\n
luaL_loadbuffer luaL_loadbuffer(lua_State *L, const char *buff, size_t sz, const char *name) [int]\nEquivalent to `luaL_loadbufferx` with `mode` equal to `NULL`.\n
luaL_loadbufferx luaL_loadbufferx(lua_State *L, const char *buff, size_t sz, const char *name, const char *mode) [int]\nLoads a buffer as a Lua chunk.  This function uses `lua_load` to load the\nchunk in the buffer pointed to by `buff` with size `sz`.\n\nThis function returns the same results as `lua_load`.  `name` is the chunk\nname, used for debug information and error messages.  The string `mode` works as\nin function `lua_load`.\n
luaL_loadfile luaL_loadfile(lua_State *L, const char *filename) [int]\nEquivalent to `luaL_loadfilex` with `mode` equal to `NULL`.\n
luaL_loadfilex luaL_loadfilex(lua_State *L, const char *filename, const char *mode) [int]\nLoads a file as a Lua chunk.  This function uses `lua_load` to load the chunk\nin the file named `filename`.  If `filename` is `NULL`, then it loads from the\nstandard input.  The first line in the file is ignored if it starts with a `#`.\n\nThe string `mode` works as in function `lua_load`.\n\nThis function returns the same results as `lua_load`, but it has an extra\nerror code `LUA_ERRFILE` if it cannot open/read the file or the file has a wrong\nmode.\n\nAs `lua_load`, this function only loads the chunk; it does not run it.\n
luaL_loadstring luaL_loadstring(lua_State *L, const char *s) [int]\nLoads a string as a Lua chunk.  This function uses `lua_load` to load the\nchunk in the zero-terminated string `s`.\n\nThis function returns the same results as `lua_load`.\n\nAlso as `lua_load`, this function only loads the chunk; it does not run it.\n
luaL_newlib luaL_newlib(lua_State *L, const luaL_Reg *l) [int]\nCreates a new table and registers there the functions in list `l`.  It is\nimplemented as the following macro:\n\n  (luaL_newlibtable(L,l), luaL_setfuncs(L,l,0))\n
luaL_newlibtable luaL_newlibtable(lua_State *L, const luaL_Reg l[]) [int]\nCreates a new table with a size optimized to store all entries in the array `l`\n(but does not actually store them).  It is intended to be used in conjunction\nwith `luaL_setfuncs` (see `luaL_newlib`).\n\nIt is implemented as a macro.  The array `l` must be the actual array, not a\npointer to it.\n
luaL_newmetatable luaL_newmetatable(lua_State *L, const char *tname) [int]\nIf the registry already has the key `tname`, returns 0.  Otherwise, creates\na new table to be used as a metatable for userdata, adds it to the registry\nwith key `tname`, and returns 1.\n\nIn both cases pushes onto the stack the final value associated with `tname`\nin the registry.\n
luaL_newstate luaL_newstate(void) [lua_State*]\nCreates a new Lua state.  It calls `lua_newstate` with an allocator based\non the standard C `realloc` function and then sets a panic function (see\n`lua_atpanic`) that prints an error message to the standard error output in\ncase of fatal errors.\n\nReturns the new state, or `NULL` if there is a memory allocation error.\n
luaL_openlibs luaL_openlibs(lua_State *L) [void]\nOpens all standard Lua libraries into the given state.\n
luaL_optint luaL_optint(lua_State *L, int arg, int d) [int]\nIf the function argument `arg` is a number, returns this number cast to an\n`int`.  If this argument is absent or is nil, returns `d`.  Otherwise, raises\nan error.\n
luaL_optinteger luaL_optinteger(lua_State *L, int arg, lua_Integer d) [lua_Integer]\nIf the function argument `arg` is a number, returns this number cast to a\n`lua_Integer`.  If this argument is absent or is nil, returns `d`.  Otherwise,\nraises an error.\n
luaL_optlong luaL_optlong(lua_State *L, int arg, long d) [long]\nIf the function argument `arg` is a number, returns this number cast to a\n`long`.  If this argument is absent or is nil, returns `d`.  Otherwise,\nraises an error.\n
luaL_optlstring luaL_optlstring(lua_State *L, int arg, const char *d, size_t *l) [const char*]\nIf the function argument `arg` is a string, returns this string.  If this\nargument is absent or is nil, returns `d`.  Otherwise, raises an error.\n\nIf `l` is not `NULL`, fills the position `*l` with the result's length.\n
luaL_optnumber luaL_optnumber(lua_State *L, int arg, lua_Number d) [lua_Number]\nIf the function argument `arg` is a number, returns this number.  If this\nargument is absent or is nil, returns `d`.  Otherwise, raises an error.\n
luaL_optstring luaL_optstring(lua_State *L, int arg, const char *d) [const char*]\nIf the function argument `arg` is a string, returns this string.  If this\nargument is absent or is nil, returns `d`.  Otherwise, raises an error.\n
luaL_optunsigned luaL_optunsigned(lua_State *L, int arg, lua_Unsigned u) [lua_Unsigned]\nIf the function argument `arg` is a number, returns this number cast to a\n`lua_Unsigned`.  If this argument is absent or is nil, returns `u`.  Otherwise,\nraises an error.\n
luaL_prepbuffer luaL_prepbuffer(luaL_Buffer *B) [char*]\nEquivalent to `luaL_prepbuffsize` with the predefined size `LUAL_BUFFERSIZE`.\n
luaL_prepbuffsize luaL_prepbuffsize(luaL_Buffer *B, size_t sz) [char*]\nReturns an address to a space of size `LUAL_BUFFERSIZE` where you can copy\na string to be added to buffer `B` (see `luaL_Buffer`).  After copying the\nstring into this space you must call `luaL_addsize` with the size of the\nstring to actually add it to the buffer.\n
luaL_pushresult luaL_pushresult(luaL_Buffer *B) [void]\nFinishes the use of buffer `B` leaving the final string on the top of\nthe stack.\n
luaL_pushresultsize luaL_pushresultsize(luaL_Buffer *B, size_t sz) [void]\nEquivalent to the sequence `luaL_addsize`, `luaL_pushresult`.\n
luaL_ref luaL_ref(lua_State *L, int t) [int]\nCreates and returns a _reference_, in the table at index `t`, for the object\nat the top of the stack (and pops the object).\n\nA reference is a unique integer key.  As long as you do not manually add\ninteger keys into table `t`, `luaL_ref` ensures the uniqueness of the key\nit returns.  You can retrieve an object referred by reference `r` by calling\n`lua_rawgeti(L, t, r)`.  Function `luaL_unref` frees a reference and its\nassociated object.\n\nIf the object at the top of the stack is nil, `luaL_ref` returns the constant\n`LUA_REFNIL`.  The constant `LUA_NOREF` is guaranteed to be different from\nany reference returned by `luaL_ref`.\n
luaL_Reg luaL_Reg [struct]\ntypedef struct luaL_Reg {\n  const char *name;\n  lua_CFunction func;\n} luaL_Reg;\n\nType for arrays of functions to be registered by `luaL_setfuncs\nis the function name and `func` is a pointer to the function.  Any array of\n`luaL_Reg` must end with an sentinel entry in which both `name` and `func`\nare `NULL`.\n
luaL_requiref luaL_requiref(lua_State *L, const char *modname, lua_CFunction openf, int glb) [void]\nCalls function `openf` with string `modname` as an argument and sets the call\nresult in `package.loaded[modname]`, as if that function has been called through\n`require`.\n\nIf `glb` is true, also stores the result into global `modname`.\n\nLeaves a copy of that result on the stack.\n
luaL_setfuncs luaL_setfuncs(lua_State *L, const luaL_Reg *l, int nup) [void]\nRegisters all functions in the array `l` (see `luaL_Reg`) into the table on the\ntop of the stack (below optional upvalues, see next).\n\nWhen `nup` is not zero, all functions are created sharing `nup` upvalues, which\nmust be previously pushed on the stack on top of the library table.  These\nvalues are popped from the stack after the registration.\n
luaL_setmetatable luaL_setmetatable(lua_State *L, const char *tname) [void]\nSets the metatable of the object at the top of the stack as the metatable\nassociated with name `tname` in the registry (see `luaL_newmetatable`).\n
luaL_testudata luaL_testudata(lua_State *L, int arg, const char *tname) [void]\nThis function works like `luaL_checkudata`, except that, when the test fails,\nit returns `NULL` instead of throwing an error.\n
luaL_tolstring luaL_tolstring(lua_State *L, int idx, size_t *len) [const char*]\nConverts any Lua value at the given acceptable index to a C string in a\nreasonable format.  The resulting string is pushed onto the stack and also\nreturned by the function.  If `len` is not `NULL`, the function also sets `*len`\nwith the string length.\n\nIf the value has a metatable with a `"__tostring"` field, then `luaL_tolstring`\ncalls the corresponding metamethod with the value as argument, and uses the\nresult of the call as its result.\n
luaL_traceback luaL_traceback(lua_State *L, lua_State *L1, const char *msg, int level) [void]\nCreates and pushes a traceback of the stack `L1`.  If `msg` is not `NULL` it is\nappended at the beginning of the traceback.  The `level` parameter tells at\nwhich level to start the traceback.\n
luaL_typename luaL_typename(lua_State *L, int index) [const char*]\nReturns the name of the type of the value at the given index.\n
luaL_unref luaL_unref(lua_State *L, int t, int ref) [void]\nReleases reference `ref` from the table at index `t` (see `luaL_ref`).\nThe entry is removed from the table, so that the referred object can be\ncollected.  The reference `ref` is also freed to be used again.\n\nIf `ref` is `LUA_NOREF` or `LUA_REFNIL`, `luaL_unref` does nothing.\n
luaL_where luaL_where(lua_State *L, int lvl) [void]\nPushes onto the stack a string identifying the current position of the\ncontrol at level `lvl` in the call stack.  Typically this string has the\nfollowing format:\n\n  _chunkname_:_currentline_:\n\nLevel 0 is the running function, level 1 is the function that called the\nrunning function, etc.\n\nThis function is used to build a prefix for error messages.\n
