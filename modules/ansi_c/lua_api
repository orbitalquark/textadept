lua_absindex lua_absindex(lua_State *L, int idx) [int]\nConverts the acceptable index `idx` into an absolute index (that is, one that does not depend\non the stack size).\n
lua_Alloc (*lua_Alloc)(void *ud, void *ptr, size_t osize, size_t nsize) [void*]\nThe type of the memory-allocation function used by Lua states.  The allocator function must provide\na functionality similar to `realloc`, but not exactly the same.  Its arguments are `ud`, an opaque\npointer passed to `lua_newstate`; `ptr`, a pointer to the block being allocated/reallocated/freed;\n`osize`, the original size of the block or some code about what is being allocated; and `nsize`,\nthe new size of the block.\n\nWhen `ptr` is not `NULL`, `osize` is the size of the block pointed by `ptr`, that is, the size\ngiven when it was allocated or reallocated.\n\nWhen `ptr` is `NULL`, `osize` encodes the kind of object that Lua is allocating.  `osize` is\nany of `LUA_TSTRING`, `LUA_TTABLE`, `LUA_TFUNCTION`, `LUA_TUSERDATA`, or `LUA_TTHREAD` when\n(and only when) Lua is creating a new object of that type.  When `osize` is some other value,\nLua is allocating memory for something else.\n\nLua assumes the following behavior from the allocator function:\n\nWhen `nsize` is zero, the allocator must behave like `free` and then return `NULL`.\n\nWhen `nsize` is not zero, the allocator must behave like `realloc`.  In particular, the allocator\nreturns `NULL` if and only if it cannot fulfill the request.\n\nHere is a simple implementation for the allocator function.  It is used in the auxiliary library\nby `luaL_newstate`.\n\n  static void *l_alloc (void *ud, void *ptr, size_t osize, size_t nsize) {\n    (void)ud;  (void)osize;  /* not used */\n    if (nsize == 0) {\n      free(ptr);\n      return NULL;\n    }\n    else\n      return realloc(ptr, nsize);\n  }\n\nNote that Standard C ensures that `free(NULL)` has no effect and that `realloc(NULL, size)`\nis equivalent to `malloc(size)`.\n
lua_arith lua_arith(lua_State *L, int op) [void]\nPerforms an arithmetic or bitwise operation over the two values (or one, in the case of negations)\nat the top of the stack, with the value on the top being the second operand, pops these values,\nand pushes the result of the operation.  The function follows the semantics of the corresponding\nLua operator (that is, it may call metamethods).\n\nThe value of `op` must be one of the following constants:\n\n  * LUA_OPADD: performs addition (`+`)\n  * LUA_OPSUB: performs subtraction (`-`)\n  * LUA_OPMUL: performs multiplication (`*`)\n  * LUA_OPDIV: performs float division (`/`)\n  * LUA_OPIDIV: performs floor division (`//`)\n  * LUA_OPMOD: performs modulo (`%`)\n  * LUA_OPPOW: performs exponentiation (`^`)\n  * LUA_OPUNM: performs mathematical negation (unary `-`)\n  * LUA_OPBNOT: performs bitwise NOT (`~`)\n  * LUA_OPBAND: performs bitwise AND (`&`)\n  * LUA_OPBOR: performs bitwise OR (`|`)\n  * LUA_OPBXOR: performs bitwise exclusive OR (`~`)\n  * LUA_OPBSHL: performs left shift (`<<`)\n  * LUA_OPBSHR: performs right shift (`>>`)\n
lua_atpanic lua_atpanic(lua_State *L, lua_CFunction panicf) [lua_CFunction]\nSets a new panic function and returns the old one (see §4.4).\n
lua_call lua_call(lua_State *L, int nargs, int nresults) [void]\nCalls a function.  Like regular Lua calls, `lua_call` respects the `__call` metamethod.  So,\nhere the word "function" means any callable value.\n\nTo do a call you must use the following protocol: first, the function to be called is pushed\nonto the stack; then, the arguments to the call are pushed in direct order; that is, the first\nargument is pushed first.  Finally you call `lua_call`; `nargs` is the number of arguments that\nyou pushed onto the stack.  When the function returns, all arguments and the function value are\npopped and the call results are pushed onto the stack when the function returns.  The number\nof results is adjusted to `nresults`, unless `nresults` is `LUA_MULTRET`.  In this case, all\nresults from the function are pushed.  Lua takes care that the returned values fit into the\nstack space, but it does not ensure any extra space on the stack.  The function results are\npushed onto the stack in direct order (the first result is pushed first), so that after the\ncall the last result is on the top of the stack.\n\nAny error while calling and running the function is propagated upwards (with a `longjmp`).\n\nThe following example shows how the host program can do the equivalent to this Lua code:\n\n  a = f("how", t.x, 14)\n\nHere it is in C:\n\n  lua_getglobal(L, "f");                  /* function to be called */\n  lua_pushliteral(L, "how");                       /* 1st argument */\n  lua_getglobal(L, "t");                    /* table to be indexed */\n  lua_getfield(L, -1, "x");        /* push result of t.x (2nd arg) */\n  lua_remove(L, -2);                  /* remove 't' from the stack */\n  lua_pushinteger(L, 14);                          /* 3rd argument */\n  lua_call(L, 3, 1);     /* call 'f' with 3 arguments and 1 result */\n  lua_setglobal(L, "a");                         /* set global 'a' */\n\nNote that the code above is _balanced_: at its end, the stack is back to its original\nconfiguration.  This is considered good programming practice.\n
lua_callk lua_callk(lua_State *L, int nargs, int nresults, lua_KContext ctx, lua_KFunction k) [void]\nThis function behaves exactly like `lua_call`, but allows the called function to yield (see §4.5).\n
lua_CFunction (*lua_CFunction)(lua_State *L) [int]\nType for C functions.\n\nIn order to communicate properly with Lua, a C function must use the following protocol, which\ndefines the way parameters and results are passed: a C function receives its arguments from Lua\nin its stack in direct order (the first argument is pushed first).  So, when the function starts,\n`lua_gettop(L)` returns the number of arguments received by the function.  The first argument\n(if any) is at index 1 and its last argument is at index `lua_gettop(L)`.  To return values to\nLua, a C function just pushes them onto the stack, in direct order (the first result is pushed\nfirst), and returns in C the number of results.  Any other value in the stack below the results\nwill be properly discarded by Lua.  Like a Lua function, a C function called by Lua can also\nreturn many results.\n\nAs an example, the following function receives a variable number of numerical arguments and\nreturns their average and their sum:\n\n  static int foo (lua_State *L) {\n    int n = lua_gettop(L);    /* number of arguments */\n    lua_Number sum = 0.0;\n    int i;\n    for (i = 1; i <= n; i++) {\n      if (!lua_isnumber(L, i)) {\n        lua_pushliteral(L, "incorrect argument");\n        lua_error(L);\n      }\n      sum += lua_tonumber(L, i);\n    }\n    lua_pushnumber(L, sum/n);        /* first result */\n    lua_pushnumber(L, sum);         /* second result */\n    return 2;                   /* number of results */\n  }\n
lua_checkstack lua_checkstack(lua_State *L, int n) [int]\nEnsures that the stack has space for at least `n` extra slots, that is, that you can safely push\nup to `n` values onto it.  It returns false if it cannot fulfill the request, either because\nit would cause the stack to be greater than a fixed maximum size (typically at least several\nthousand elements) or because it cannot allocate memory for the extra space.  This function\nnever shrinks the stack; if the stack already has space for the extra slots, it is left unchanged.\n
lua_close lua_close(lua_State *L) [void]\nClose all active to-be-closed variables in the main thread, release all objects in the given\nLua state (calling the corresponding garbage-collection metamethods, if any), and frees all\ndynamic memory used by this state.\n\nOn several platforms, you may not need to call this function, because all resources are\nnaturally released when the host program ends.  On the other hand, long-running programs that\ncreate multiple states, such as daemons or web servers, will probably need to close states as\nsoon as they are not needed.\n\n
lua_compare lua_compare(lua_State *L, int index1, int index2, int op) [int]\nCompares two Lua values.  Returns 1 if the value at index `index1` satisfies `op` when compared\nwith the value at index `index2`, following the semantics of the corresponding Lua operator\n(that is, it may call metamethods).  Otherwise returns 0.  Also returns 0 if any of the indices\nis not valid.\n\nThe value of `op` must be one of the following constants:\n\n  * LUA_OPEQ: compares for equality (`==`)\n  * LUA_OPLT: compares for less than (`<`)\n  * LUA_OPLE: compares for less or equal (`<=`)\n
lua_concat lua_concat(lua_State *L, int n) [void]\nConcatenates the `n` values on the top of the stack, pops them, and leaves the result at the top.\nIf `n` is 1, the result is the single value on the stack (that is, the function does nothing);\nif `n` is 0, the result is the empty string.  Concatenation is performed following the usual\nsemantics of Lua (see §3.4.6).\n
lua_copy lua_copy(lua_State *L, int fromidx, int toidx) [void]\nCopies the element at index `fromidx` into the valid index `toidx`, replacing the value at\nthat position.  Values at other positions are not affected.\n
lua_createtable lua_createtable(lua_State *L, int narr, int nrec) [void]\nCreates a new empty table and pushes it onto the stack.  Parameter `narr` is a hint for how\nmany elements the table will have as a sequence; parameter `nrec` is a hint for how many other\nelements the table will have.  Lua may use these hints to preallocate memory for the new table.\nThis preallocation may help performance when you know in advance how many elements the table\nwill have.  Otherwise you can use the function `lua_newtable`.\n
lua_dump lua_dump(lua_State *L, lua_Writer writer, void *data, int strip) [int]\nDumps a function as a binary chunk.  Receives a Lua function on the top of the stack and produces\na binary chunk that, if loaded again, results in a function equivalent to the one dumped.\nAs it produces parts of the chunk, `lua_dump` calls function `writer` (see `lua_Writer`) with\nthe given `data` to write them.\n\nIf `strip` is true, the binary representation is created without debug information about the\nfunction.\n\nThe value returned is the error code returned by the last call to the writer; 0 means no errors.\n\nThis function does not pop the Lua function from the stack.\n\n
lua_error lua_error(lua_State *L) [int]\nRaises a Lua error, using the value on the top of the stack as the error object.  This function\ndoes a long jump, and therefore never returns (see `luaL_error`).\n
lua_gc lua_gc(lua_State *L, int what, ...) [int]\nControls the garbage collector.\n\nThis function performs several tasks, according to the value of the parameter `what`.  For options\nthat need extra arguments, they are listed after the option.\n\n  * LUA_GCCOLLECT: Performs a full garbage-collection cycle.\n  * LUA_GCSTOP: Stops the garbage collector.\n  * LUA_GCRESTART: Restarts the garbage collector.\n  * LUA_GCCOUNT: Returns the current amount of memory (in Kbytes) in use by Lua.\n  * LUA_GCCOUNTB: Returns the remainder of dividing the current amount of bytes of memory in\n    use by Lua by 1024.\n  * LUA_GCSTEP `(int stepsize)`: Performs an incremental step of garbage collection\n  * LUA_GCISRUNNING: Returns a boolean that tells whether the collector is running (i.e.,\n    not stopped).\n  * LUA_GCINC (int pause, int stepmul, stepsize): Changes the collector to incremental mode with\n    the given parameters (see §2.5.1).  Returns the previous mode (`LUA_GCGEN` or `LUA_GCINC`).\n  * LUA_GCGEN (int minomul, int majormul): Changes the collector to generational mode with the\n    given parameters (see §2.5.2).  Returns the previous mode (`LUA_GCGEN` or `LUA_GCINC`).\n\nFor more details about these options, see `collectgarbage`.\n
lua_getallocf lua_getallocf(lua_State *L, void **ud) [lua_Alloc]\nReturns the memory-allocation function of a given state.  If `ud` is not `NULL`, Lua stores in\n`*ud` the opaque pointer given when the memory-allocator function was set.\n
lua_getextraspace lua_getextraspace(lua_State *L) [void*]\nReturns a pointer to a raw memory area associated with the given Lua state.  The application\ncan use this area for any purpose; Lua does not use it for anything.\n\nEach new thread has this area initialized with a copy of the area of the main thread.\n\nBy default, this area has the size of a pointer to void, but you can recompile Lua with a\ndifferent size for this area.  (See `LUA_EXTRASPACE` in `luaconf.h`.)\n\n
lua_getfield lua_getfield(lua_State *L, int index, const char *k) [int]\nPushes onto the stack the value `t[k]`, where `t` is the value at the given index.  As in Lua,\nthis function may trigger a metamethod for the "index" event (see §2.4).\n\nReturns the type of the pushed value.\n
lua_getglobal lua_getglobal(lua_State *L, const char *name) [int]\nPushes onto the stack the value of the global `name`.  Returns the type of that value.\n
lua_geti lua_geti(lua_State *L, int index, lua_Integer i) [int]\nPushes onto the stack the value `t[i]`, where `t` is the value at the given index.  As in Lua,\nthis function may trigger a metamethod for the "index" event (see §2.4).\n\nReturns the type of the pushed value.\n\n
lua_getmetatable lua_getmetatable(lua_State *L, int index) [int]\nIf the value at the given index has a metatable, the function pushes that metatable onto the\nstack and returns 1.  Otherwise, the function returns 0 and pushes nothing on the stack.\n
lua_gettable lua_gettable(lua_State *L, int index) [int]\nPushes onto the stack the value `t[k]`, where `t` is the value at the given index and `k`\nis the value on the top of the stack.\n\nThis function pops the key from the stack, pushing the resulting value in its place.  As in Lua,\nthis function may trigger a metamethod for the "index" event (see §2.4).\n\nReturns the type of the pushed value.\n\n
lua_gettop lua_gettop(lua_State *L) [int]\nReturns the index of the top element in the stack.  Because indices start at 1, this result is\nequal to the number of elements in the stack; in particular, 0 means an empty stack.\n\n
lua_getiuservalue lua_getiuservalue(lua_State *L, int index, int n) [int]\nPushes onto the stack the `n`-th user value associated with the full userdata at the given\nindex and returns the type of the pushed value.\n\nIf the userdata does not have that value, pushes `nil` and returns `LUA_TNONE`.\n\n
lua_insert lua_insert(lua_State *L, int index) [void]\nMoves the top element into the given valid index, shifting up the elements above this index to\nopen space.  This function cannot be called with a pseudo-index, because a pseudo-index is not\nan actual stack position.\n
lua_Integer lua_Integer [typedef ... lua_Integer]\nThe type of integers in Lua.\n\nBy default this type is `long long`, (usually a 64-bit two-complement integer), but that can\nbe changed to `long` or `int` (usually a 32-bit two-complement integer).  (See `LUA_INT` in\n`luaconf.h`.)\n\nLua also defines the constants `LUA_MININTEGER` and `LUA_MAXINTEGER`, with the minimum and the\nmaximum values that fit in this type.\n\n
lua_isboolean lua_isboolean(lua_State *L, int index) [int]\nReturns 1 if the value at the given index is a boolean, and 0 otherwise.\n
lua_iscfunction lua_iscfunction(lua_State *L, int index) [int]\nReturns 1 if the value at the given index is a C function, and 0 otherwise.\n
lua_isfunction lua_isfunction(lua_State *L, int index) [int]\nReturns 1 if the value at the given index is a function (either C or Lua), and 0 otherwise.\n
lua_isinteger lua_isinteger(lua_State *L, int index) [int]\nReturns 1 if the value at the given index is an integer (that is, the value is a number and is\nrepresented as an integer), and 0 otherwise.\n
lua_islightuserdata lua_islightuserdata(lua_State *L, int index) [int]\nReturns 1 if the value at the given index is a light userdata, and 0 otherwise.\n
lua_isnil lua_isnil(lua_State *L, int index) [int]\nReturns 1 if the value at the given index is nil, and 0 otherwise.\n
lua_isnone lua_isnone(lua_State *L, int index) [int]\nReturns 1 if the given index is not valid, and 0 otherwise.\n
lua_isnoneornil lua_isnoneornil(lua_State *L, int index) [int]\nReturns 1 if the given index is not valid or if the value at this index is nil, and 0 otherwise.\n
lua_isnumber lua_isnumber(lua_State *L, int index) [int]\nReturns 1 if the value at the given index is a number or a string convertible to a number,\nand 0 otherwise.\n
lua_isstring lua_isstring (lua_State *L, int index) [int]\nReturns 1 if the value at the given index is a string or a number (which is always convertible\nto a string), and 0 otherwise.\n
lua_istable lua_istable(lua_State *L, int index) [int]\nReturns 1 if the value at the given index is a table, and 0 otherwise.\n
lua_isthread lua_isthread(lua_State *L, int index) [int]\nReturns 1 if the value at the given index is a thread, and 0 otherwise.\n
lua_isuserdata lua_isuserdata(lua_State *L, int index) [int]\nReturns 1 if the value at the given index is a userdata (either full or light), and 0 otherwise.\n
lua_isyieldable lua_isyieldable(lua_State *L) [int]\nReturns 1 if the given coroutine can yield, and 0 otherwise.\n
lua_KContext lua_KContext [typedef ... lua_KContext]\nThe type for continuation-function contexts.  It must be a numerical type.  This type is defined\nas `intptr_t` when `intptr_t` is available, so that it can store pointers too.  Otherwise,\nit is defined as `ptrdiff_t`.\n
lua_KFunction lua_KFunction [int (*)(lua_State *L, int status, lua_KContext ctx)]\nType for continuation functions (see §4.5).\n
lua_len lua_len(lua_State *L, int index) [void]\nReturns the length of the value at the given index.  It is equivalent to the '`#`' operator in\nLua (see §3.4.7) and may trigger a metamethod for the "length" event (see §2.4).  The result\nis pushed on the stack.\n\n
lua_load lua_load(lua_State *L, lua_Reader reader, void *data, const char *chunkname, const char *mode) [int]\nLoads a Lua chunk without running it.  If there are no errors, `lua_load` pushes the compiled\nchunk as a Lua function on top of the stack.  Otherwise, it pushes an error message.\n\nThe `lua_load` function uses a user-supplied `reader` function to read the chunk (see\n`lua_Reader`).  The `data` argument is an opaque value passed to the reader function.\n\nThe `chunkname` argument gives a name to the chunk, which is used for error messages and in\ndebug information (see §4.7).\n\n`lua_load` automatically detects whether the chunk is text or binary and loads it accordingly\n(see program `luac`).  The string `mode` works as in function `load`, with the addition that a\n`NULL` value is equivalent to the string "`bt`".\n\n`lua_load` uses the stack internally, so the reader function must always leave the stack\nunmodified when returning.\n\n`lua_load` can return `LUA_OK`, `LUA_ERRSYNTAX`, or `LUA_ERRMEM`.  The function may also return\nother values corresponding to errors raised by the read function (see §4.4.1).\n\nIf the resulting function has upvalues, its first upvalue is set to the value of the global\nenvironment stored at index `LUA_RIDX_GLOBALS` in the registry (see §4.3).  When loading main\nchunks, this upvalue will be the `_ENV` variable (see §2.2).  Other upvalues are initialized\nwith `nil`.\n\n
lua_newstate lua_newstate(lua_Alloc f, void *ud) [lua_State*]\nCreates a new independent state and returns its main thread.  Returns `NULL` if it cannot create\nthe thread or the state (due to lack of memory).  The argument `f` is the allocator function;\nLua will do all memory allocation for this state through this function.  The second argument,\n`ud`, is an opaque pointer that Lua passes to the allocator in every call.\n\n
lua_newtable lua_newtable(lua_State *L) [void]\nCreates a new empty table and pushes it onto the stack.  It is equivalent to\n`lua_createtable(L, 0, 0)`.\n
lua_newthread lua_newthread(lua_State *L) [lua_State*]\nCreates a new thread, pushes it on the stack, and returns a pointer to a `lua_State` that\nrepresents this new thread.  The new thread returned by this function shares with the original\nthread its global environment, but has an independent execution stack.\n\nThreads are subject to garbage collection, like any Lua object.\n
lua_newuserdatauv lua_newuserdatauv(lua_State *L, size_t size, int nuvalue) [void*]\nThis function creates and pushes on the stack a new full userdata, with `nuvalue` associated Lua\nvalues, called *user values*, plus an associated block of raw memory with `size` bytes.  (The user\nvalues can be set and read with the functions `lua_setiuservalue` and `lua_getiuservalue`.)\n\nThe function returns the address of the block of memory.  Lua ensures that this address is valid\nas long as the corresponding userdata is alive (see §2.5).  Moreover, if the userdata is marked\nfor finalization (see §2.5.3), its address is valid at least until the call to its finalizer.\n
lua_next lua_next(lua_State *L, int index) [int]\nPops a key from the stack, and pushes a key-value pair from the table at the given index, the\n"next" pair after the given key.  If there are no more elements in the table, then `lua_next`\nreturns 0 and pushes nothing.\n\nA typical table traversal looks like this:\n\n  /* table is in the stack at index 't' */\n  lua_pushnil(L);  /* first key */\n  while (lua_next(L, t) != 0) {\n    /* uses 'key' (at index -2) and 'value' (at index -1) */\n    printf("%s - %s\n",\n           lua_typename(L, lua_type(L, -2)),\n           lua_typename(L, lua_type(L, -1)));\n    /* removes 'value'; keeps 'key' for next iteration */\n    lua_pop(L, 1);\n  }\n\nWhile traversing a table, avoid calling `lua_tolstring` directly on a key, unless you know that\nthe key is actually a string.  Recall that `lua_tolstring` may change the value at the given\nindex; this confuses the next call to `lua_next`.\n\nThis function may raise an error if the given key is neither nil nor present in the table.\nSee function `next` for the caveats of modifying the table during its traversal.\n
lua_Number lua_Number [double]\nThe type of floats in Lua.  By default this type is double, but that can be changed to a\nsingle float.  (See `LUA_REAL` in `luaconf.h`.)\n
lua_numbertointeger lua_numbertointeger(lua_Number n, lua_Integer *p) [int]\nTries to convert a Lua float to a Lua integer; the float `n` must have an integral value.\nIf that value is within the range of Lua integers, it is converted to an integer and assigned\nto `*p`.  The macro results in a boolean indicating whether the conversion was successful.\n(Note that this range test can be tricky to do correctly without this macro, due to rounding.)\n\nThis macro may evaluate its arguments more than once.\n
lua_pcall lua_pcall(lua_State *L, int nargs, int nresults, int msgh) [int]\nCalls a function (or a callable object) in protected mode.\n\nBoth `nargs` and `nresults` have the same meaning as in `lua_call`.  If there are no errors\nduring the call, `lua_pcall` behaves exactly like `lua_call`.  However, if there is any error,\n\n`lua_pcall` catches it, pushes a single value on the stack (the error object), and returns an\nerror code.  Like `lua_call`, `lua_pcall` always removes the function and its arguments from\nthe stack.\n\nIf `msgh` is 0, then the error object returned on the stack is exactly the original error object.\nOtherwise, `msgh` is the stack index of a _message handler_.  (In the current implementation,\nthis index cannot be a pseudo-index.)  In case of runtime errors, this handler will be called\nwith the error object and its return value will be the object returned on the stack by `lua_pcall`.\n\nTypically, the message handler is used to add more debug information to the error object, such\nas a stack traceback.  Such information cannot be gathered after the return of `lua_pcall`,\nsince by then the stack has unwound.\n\nThe `lua_pcall` function returns one of the following status codes: `LUA_OK`, `LUA_ERRRUN`,\n`LUA_ERRMEM`, or `LUA_ERRERR`.\n
lua_pcallk lua_pcallk(lua_State *L, int nargs, int nresults, int msgh, lua_KContext ctx, lua_KFunction k) [int]\nThis function behaves exactly like `lua_pcall`, except that it allows the called function to\nyield (see §4.5).\n
lua_pop lua_pop(lua_State *L, int n) [void]\nPops `n` elements from the stack.\n\nThis function can run arbitrary code when removing an index marked as to-be-closed from the stack.\n
lua_pushboolean lua_pushboolean(lua_State *L, int b) [void]\nPushes a boolean value with value `b` onto the stack.\n
lua_pushcclosure lua_pushcclosure(lua_State *L, lua_CFunction fn, int n) [void]\nPushes a new C closure onto the stack.\n\nThis function receives a pointer to a C function and pushes onto the stack a Lua value of type\n`function` that, when called, invokes the corresponding C function.  The parameter `n` tells\nhow many upvalues this function will have (see §4.2).\n\nAny function to be callable by Lua must follow the correct protocol to receive its parameters\nand return its results (see `lua_CFunction`).\n\nWhen a C function is created, it is possible to associate some values with it, the so\ncalled upvalues; these upvalues are then accessible to the function whenever it is called.\nThis association is called a C closure (see §4.2).  To create a C closure, first the initial\nvalues for its upvalues must be pushed onto the stack.  (When there are multiple values, the first\nvalue is pushed first.)  Then `lua_pushcclosure` is called to create and push the C function onto\nthe stack, with the argument `n` telling how many values will be associated with the function.\n`lua_pushcclosure` also pops these values from the stack.\n\nThe maximum value for `n` is 255.\n\nWhen `n` is zero, this function creates a _light C function_, which is just a pointer to the\nC function.  In that case, it never raises a memory error.\n
lua_pushcfunction lua_pushcfunction(lua_State *L, lua_CFunction f) [void]\nPushes a C function onto the stack.  This function is equivalent to `lua_pushcclosure` with\nno upvalues.\n
lua_pushfstring lua_pushfstring(lua_State *L, const char *fmt, ...) [const char*]\nPushes onto the stack a formatted string and returns a pointer to this string (see §4.1.3).\nIt is similar to the ISO C function `sprintf`, but has two important differences.  First, you do\nnot have to allocate space for the result; the result is a Lua string and Lua takes care of memory\nallocation (and deallocation, through garbage collection).  Second, the conversion specifiers\nare quite restricted.  There are no flags, widths, or precisions.  The conversion specifiers can\nonly be '%%' (inserts the character '%' in the string), '%s' (inserts a zero-terminated string,\nwith no size restrictions), '%f' (inserts a `lua_Number`), '%L' (inserts a `lua_Integer`), '%p'\n(inserts a pointer as a hexadecimal numeral), '%d' (inserts an `int`), '%c' (inserts an `int`\nas a one-byte character), and '%U' (inserts a `long int` as a UTF-8 byte sequence).\n\nThis function may raise errors due to memory overflow or an invalid conversion specifier.\n
lua_pushglobaltable lua_pushglobaltable(lua_State *L) [void]\nPushes the global environment onto the stack.\n
lua_pushinteger lua_pushinteger(lua_State *L, lua_Integer n) [void]\nPushes an integer with value `n` onto the stack.\n
lua_pushlightuserdata lua_pushlightuserdata(lua_State *L, void *p) [void]\nPushes a light userdata onto the stack.\n\nUserdata represent C values in Lua.  A _light userdata_ represents a pointer, a `void*`.  It is\na value (like a number): you do not create it, it has no individual metatable, and it is not\ncollected (as it was never created).  A light userdata is equal to "any" light userdata with\nthe same C address.\n
lua_pushliteral lua_pushliteral(lua_State *L, const char *s) [const char*]\nThis macro is equivalent to `lua_pushlstring`, but can be used only when `s` is a literal string.\n(Lua may optimize this case.)\n
lua_pushlstring lua_pushlstring(lua_State *L, const char *s, size_t len) [const char*]\nPushes the string pointed to by `s` with size `len` onto the stack.  Lua will make or reuse\nan internal copy of the given string, so the memory at `s` can be freed or reused immediately\nafter the function returns.  The string can contain any binary data, including embedded zeros.\n\nReturns a pointer to the internal copy of the string (see §4.1.3).\n
lua_pushnil lua_pushnil(lua_State *L) [void]\nPushes a nil value onto the stack.\n
lua_pushnumber lua_pushnumber(lua_State *L, lua_Number n) [void]\nPushes a float with value `n` onto the stack.\n
lua_pushstring lua_pushstring(lua_State *L, const char *s) [const char*]\nPushes the zero-terminated string pointed to by `s` onto the stack.  Lua will make or reuse\nan internal copy of the given string, so the memory at `s` can be freed or reused immediately\nafter the function returns.  The string cannot contain embedded zeros; it is assumed to end at\nthe first zero.\n\nReturns a pointer to the internal copy of the string (see §4.1.3).\n\nIf `s` is `NULL`, pushes nil and returns `NULL`.\n
lua_pushthread lua_pushthread(lua_State *L) [int]\nPushes the thread represented by `L` onto the stack.  Returns 1 if this thread is the main\nthread of its state.\n
lua_pushvalue lua_pushvalue(lua_State *L, int index) [void]\nPushes a copy of the element at the given index onto the stack.\n
lua_pushvfstring lua_pushvfstring(lua_State *L, const char *fmt, va_list argp) [const char*]\nEquivalent to `lua_pushfstring`, except that it receives a `va_list` instead of a variable\nnumber of arguments.\n
lua_rawequal lua_rawequal(lua_State *L, int index1, int index2) [int]\nReturns 1 if the two values in indices `index1` and `index2` are primitively equal (that is,\nequal without calling the `__eq` metamethod).  Otherwise returns 0. Also returns 0 if any of\nthe indices are not valid.\n
lua_rawget lua_rawget(lua_State *L, int index) [int]\nSimilar to `lua_gettable`, but does a raw access (i.e., without metamethods).\n
lua_rawgeti lua_rawgeti(lua_State *L, int index, lua_Integer n) [int]\nPushes onto the stack the value `t[n]`, where `t` is the table at the given index.  The access\nis raw, that is, it does not use the `__index` metavalue.\n\nReturns the type of the pushed value.\n
lua_rawgetp lua_rawgetp(lua_State *L, int index, const void *p) [int]\nPushes onto the stack the value `t[k]`, where `t` is the table at the given index and `k` is the\npointer `p` represented as a light userdata.  The access is raw, that is, it does not use the\n`__index` metavalue.\n\nReturns the type of the pushed value.\n
lua_rawlen lua_rawlen(lua_State *L, int index) [lua_Unsigned]\nReturns the raw "length" of the value at the given index: for strings, this is the string length;\nfor tables, this is the result of the length operator ('`#`') with no metamethods; for userdata,\nthis is the size of the block of memory allocated for the userdata. For other values, this call\nreturns 0.\n
lua_rawset lua_rawset(lua_State *L, int index) [void]\nSimilar to `lua_settable`, but does a raw assignment (i.e., without metamethods).\n
lua_rawseti lua_rawseti(lua_State *L, int index, lua_Integer i) [void]\nDoes the equivalent of `t[i] = v`, where `t` is the table at the given index and `v` is the\nvalue on the top of the stack.\n\nThis function pops the value from the stack.  The assignment is raw, that is, it does not use\nthe `__newindex` metavalue.\n
lua_rawsetp lua_rawsetp(lua_State *L, int index, const void *p) [void]\nDoes the equivalent of `t[k] = v`, where `t` is the table at the given index, `k` is the pointer\n`p` represented as a light userdata, and `v` is the value on the top of the stack.\n\nThis function pops the value from the stack.  The assignment is raw, that is, it does not use\nthe `__newindex` metavalue.\n
lua_Reader (*lua_Reader)(lua_State *L, void *data, size_t *size) [const char*]\nThe reader function used by `lua_load`.  Every time `lua_load` needs another piece of the chunk,\nit calls the reader, passing along its `data` parameter.  The reader must return a pointer to a\nblock of memory with a new piece of the chunk and set `size` to the block size.  The block must\nexist until the reader function is called again.  To signal the end of the chunk, the reader\nmust return `NULL` or set `size` to zero.  The reader function may return pieces of any size\ngreater than zero.\n
lua_register lua_register(lua_State *L, const char *name, lua_CFunction f) [void]\nSets the C function `f` as the new value of global `name`.  It is defined as a macro:\n\n  #define lua_register(L,n,f) (lua_pushcfunction(L, f), lua_setglobal(L, n))\n
lua_remove lua_remove(lua_State *L, int index) [void]\nRemoves the element at the given valid index, shifting down the elements above this index to\nfill the gap.  This function cannot be called with a pseudo-index, because a pseudo-index is\nnot an actual stack position.\n
lua_replace lua_replace(lua_State *L, int index) [void]\nMoves the top element into the given valid index, without shifting any element (therefore\nreplacing the value at the given index), and then pops the top element.\n
lua_resetthread lua_resetthread(lua_State *L) [void]\nResets a thread, cleaning its call stack and closing all pending to-be-closed variables.\nReturns a status code: `LUA_OK` for no errors in closing methods, or an error status otherwise.\nIn case of error, leaves the error object on the top of the stack.\n
lua_resume lua_resume(lua_State *L, lua_State *from, int nargs, int *nresults) [int]\nStarts and resumes a coroutine in the given thread `L`.\n\nTo start a coroutine, you push the main function plus any arguments onto the empty stack of\nthe thread.  Then you call `lua_resume`, with `nargs` being the number of arguments.  This call\nreturns when the coroutine suspends or finishes its execution.  When it returns, `*nresults`\nis updated and the top of the stack contains the `*nresults` values passed to `lua_yield`\nor returned by the body function.  `lua_resume` returns `LUA_YIELD` if the coroutine yields,\n`LUA_OK` if the coroutine finishes its execution without errors, or an error code in case of\nerrors (see §4.4.1).  In case of errors, the error object is on the top of the stack.\n\nTo resume a coroutine, you remove the `*nresults` yielded values from its stack, push the values\nto be passed as results from `yield`, and then call `lua_resume`.\n\nThe parameter `from` represents the coroutine that is resuming `L`.  If there is no such coroutine,\nthis parameter can be `NULL`.\n
lua_rotate lua_rotate(lua_State *L, int index, int n) [void]\nRotates the stack elements from `index` to the top `n` positions in the direction of the top,\nfor a positive `n`, or `-n` positions in the direction of the bottom, for a negative `n`.\nThe absolute value of `n` must not be greater than the size of the slice being rotated.\n
lua_setallocf lua_setallocf(lua_State *L, lua_Alloc f, void *ud) [void]\nChanges the allocator function of a given state to `f` with user data `ud`.\n
lua_setfield lua_setfield(lua_State *L, int index, const char *k) [void]\nDoes the equivalent to `t[k] = v`, where `t` is the value at the given index and `v` is the\nvalue on the top of the stack.\n\nThis function pops the value from the stack.  As in Lua, this function may trigger a metamethod\nfor the "newindex" event (see §2.4).\n
lua_setglobal lua_setglobal(lua_State *L, const char *name) [void]\nPops a value from the stack and sets it as the new value of global `name`.\n
lua_seti lua_seti(lua_State *L, int index, lua_Integer n) [void]\nDoes the equivalent to `t[n] = v`, where `t` is the value at the given index and `v` is the\nvalue on the top of the stack.\n\nThis function pops the value from the stack.  As in Lua, this function may trigger a metamethod\nfor the "newindex" event (see §2.4).\n
lua_setiuservalue lua_setiuservalue(lua_State *L, int index, int n) [int]\nPops a value from the stack and sets it as the new `n`-th user value associated to the full\nuserdata at the given index.  Returns 0 if the userdata does not have that value.\n
lua_setmetatable lua_setmetatable(lua_State *L, int index) [int]\nPops a table or nil from the stack and sets that value as the new metatable for the value at\nthe given index (nil means no metatable).\n\n(For historical reasons, this function returns an `int`, which now is always 1.)\n
lua_settable lua_settable(lua_State *L, int index) [void]\nDoes the equivalent to `t[k] = v`, where `t` is the value at the given index, `v` is the value\non the top of the stack, and `k` is the value just below the top.\n\nThis function pops both the key and the value from the stack.  As in Lua, this function may\ntrigger a metamethod for the "newindex" event (see §2.4).\n
lua_settop lua_settop(lua_State *L, int index) [void]\nAccepts any index, or 0, and sets the stack top to this index.  If the new top is greater than\nthe old one, then the new elements are filled with nil.  If `index` is 0, then all stack elements\nare removed.\n\nThis function can run arbitrary code when removing an index marked as to-be-closed from the stack.\n
lua_setwarnf lua_setwarnf(lua_State *L, lua_WarnFunction f, void *ud) [void]\nSets the warning function to be used by Lua to emit warnings (see `lua_WarnFunction`).  The `ud`\nparameter sets the value `ud` passed to the warning function.\n
lua_State lua_State [struct lua_State]\nAn opaque structure that points to a thread and indirectly (through the thread) to the whole\nstate of a Lua interpreter.  The Lua library is fully reentrant: it has no global variables.\nAll information about a state is accessible through this structure.\n\nA pointer to this structure must be passed as the first argument to every function in the library,\nexcept to `lua_newstate`, which creates a Lua state from scratch.\n
lua_status lua_status(lua_State *L) [int]\nReturns the status of the thread `L`.\n\nThe status can be `LUA_OK` for a normal thread, an error code if the thread finished the\nexecution of a `lua_resume` with an error, or `LUA_YIELD` if the thread is suspended.\n\nYou can call functions only in threads with status `LUA_OK`.  You can resume threads with status\n`LUA_OK` (to start a new coroutine) or `LUA_YIELD` (to resume a coroutine).\n
lua_stringtonumber lua_stringtonumber(lua_State *L, const char *s) [size_t]\nConverts the zero-terminated string `s` to a number, pushes that number into the stack, and\nreturns the total size of the string, that is, its length plus one.  The conversion can result\nin an integer or a float, according to the lexical conventions of Lua (see §3.1).  The string\nmay have leading and trailing whitespaces and a sign.  If the string is not a valid numeral,\nreturns 0 and pushes nothing. (Note that the result can be used as a boolean, true if the\nconversion succeeds.)\n
lua_toboolean lua_toboolean(lua_State *L, int index) [int]\nConverts the Lua value at the given index to a C boolean value (0 or 1).  Like all tests in\nLua, `lua_toboolean` returns true for any Lua value different from false and nil; otherwise it\nreturns false.  (If you want to accept only actual boolean values, use `lua_isboolean` to test\nthe value's type.)\n
lua_toclose lua_toclose(lua_State *L, int index) [void]\nMarks the given index in the stack as a to-be-closed "variable" (see §3.3.8).  Like a to-be-closed\nvariable in Lua, the value at that index in the stack will be closed when it goes out of scope.\nHere, in the context of a C function, to go out of scope means that the running function returns to\nLua, there is an error, or the index is removed from the stack through `lua_settop` or `lua_pop`.\nAn index marked as to-be-closed should not be removed from the stack by any other function in\nthe API except `lua_settop` or `lua_pop`.\n\nThis function should not be called for an index that is equal to or below an active to-be-closed\nindex.\n\nIn the case of an out-of-memory error, the value in the given index is immediately closed,\nas if it was already marked.\n\nNote that, both in case of errors and of a regular return, by the time the `__close` metamethod\nruns, the C stack was already unwound, so that any automatic C variable declared in the calling\nfunction will be out of scope.\n
lua_tocfunction lua_tocfunction(lua_State *L, int index) [lua_CFunction]\nConverts a value at the given index to a C function.  That value must be a C function; otherwise,\nreturns `NULL`.\n
lua_tointeger lua_tointeger(lua_State *L, int index) [lua_Integer]\nEquivalent to `lua_tointegerx` with `isnum` equal to `NULL`.\n
lua_tointegerx lua_tointegerx(lua_State *L, int index, int *isnum) [lua_Integer]\nConverts the Lua value at the given index to the signed integral type `lua_Integer`.  The Lua\nvalue must be an integer, or a number or a string convertible to an integer (see §3.4.3);\notherwise, `lua_tointegerx` returns 0.\n\nIf `isnum` is not `NULL`, its referent is assigned a boolean value that indicates whether the\noperation succeeded.\n
lua_tolstring lua_tolstring(lua_State *L, int index, size_t *len) [const char*]\nConverts the Lua value at the given index to a C string.  If `len` is not `NULL`, it sets `*len`\nwith the string length.  The Lua value must be a string or a number; otherwise, the function\nreturns `NULL`.  If the value is a number, then `lua_tolstring` also _changes the actual value\nin the stack to a string_.  (This change confuses `lua_next` when `lua_tolstring` is applied\nto keys during a table traversal.)\n\n`lua_tolstring` returns a pointer to a string inside the Lua state (see §4.1.3).  This string\nalways has a zero ('\0') after its last character (as in C), but can contain other zeros in\nits body.\n
lua_tonumber lua_tonumber(lua_State *L, int index) [lua_Number]\nEquivalent to `lua_tonumberx` with `isnum` equal to `NULL`.\n
lua_tonumberx lua_tonumberx(lua_State *L, int index, int *isnum) [lua_Number]\nConverts the Lua value at the given index to the C type `lua_Number` (see `lua_Number`).\nThe Lua value must be a number or a string convertible to a number (see §3.4.3); otherwise,\n`lua_tonumberx` returns 0.\n\nIf `isnum` is not `NULL`, its referent is assigned a boolean value that indicates whether the\noperation succeeded.\n
lua_topointer lua_topointer(lua_State *L, int index) [const void*]\nConverts the value at the given index to a generic C pointer (`void*`).  The value can be a\nuserdata, a table, a thread, a string, or a function; otherwise, `lua_topointer` returns `NULL`.\nDifferent objects will give different pointers.  There is no way to convert the pointer back\nto its original value.\n\nTypically this function is used only for debug information.\n
lua_tostring lua_tostring(lua_State *L, int index) [const char*]\nEquivalent to `lua_tolstring` with `len` equal to `NULL`.\n
lua_tothread lua_tothread(lua_State *L, int index) [lua_State*]\nConverts the value at the given index to a Lua thread (represented as `lua_State*`).  This value\nmust be a thread; otherwise, the function returns `NULL`.\n
lua_touserdata lua_touserdata(lua_State *L, int index) [void*]\nIf the value at the given index is a full userdata, returns its memory-block address.  If the\nvalue is a light userdata, returns its value (a pointer).  Otherwise, returns `NULL`.\n
lua_type lua_type(lua_State *L, int index) [int]\nReturns the type of the value in the given index, or `LUA_TNONE` for a non-valid but acceptable\nindex.\n\nThe types returned by `lua_type` are coded by the following constants defined in `lua.h`:\n`LUA_TNIL`, `LUA_TNUMBER`, `LUA_TBOOLEAN`, `LUA_TSTRING`, `LUA_TTABLE`, `LUA_TFUNCTION`,\n`LUA_TUSERDATA`, `LUA_TTHREAD`, and `LUA_TLIGHTUSERDATA`.\n
lua_typename lua_typename(lua_State *L, int tp) [const char*]\nReturns the name of the type encoded by the value `tp`, which must be one the values returned by\n`lua_type`.\n
lua_Unsigned lua_Unsigned [typedef ... lua_Unsigned]\nThe unsigned version of `lua_Integer`.\n
lua_upvalueindex lua_upvalueindex(int i) [int]\nReturns the pseudo-index that represents the `i`-th upvalue of the running function (see §4.2).\n`i` must be in the range *[1,256]*.\n
lua_version lua_version(lua_State *L) [lua_Number]\nReturns the version number of this core.\n
lua_WarnFunction lua_WarnFunction [void (*)(void *ud, const char *msg, int tocont)]\nThe type of warning functions, called by Lua to emit warnings.  The first parameter is an opaque\npointer set by `lua_setwarnf`.  The second parameter is the warning message.  The third parameter\nis a boolean that indicates whether the message is to be continued by the message in the next call.\n\nSee `warn` for more details about warnings.\n
lua_warning lua_warning(lua_State *L, const char *msg, int tocont) [void]\nEmits a warning with the given message.  A message in a call with `tocont` true should be\ncontinued in another call to this function.\n\nSee `warn` for more details about warnings.\n
lua_Writer (*lua_Writer)(lua_State *L, const void* p, size_t sz, void* ud) [int]\nThe type of the writer function used by `lua_dump`.  Every time `lua_dump` produces another\npiece of chunk, it calls the writer, passing along the buffer to be written (`p`), its size\n(`sz`), and the `ud` parameter supplied to `lua_dump`.\n\nThe writer returns an error code: 0 means no errors; any other value means an error and stops\n`lua_dump` from calling the writer again.\n
lua_xmove lua_xmove(lua_State *from, lua_State *to, int n) [void]\nExchange values between different threads of the same state.\n\nThis function pops `n` values from the stack `from`, and pushes them onto the stack `to`.\n
lua_yield lua_yield(lua_State *L, int nresults) [int]\nThis function is equivalent to `lua_yieldk`, but it has no continuation (see §4.5).  Therefore,\nwhen the thread resumes, it continues the function that called the function calling `lua_yield`.\nTo avoid surprises, this function should be called only in a tail call.\n
lua_yieldk lua_yieldk(lua_State *L, int nresults, lua_KContext ctx, lua_KFunction k) [int]\nYields a coroutine (thread).\n\nWhen a C function calls `lua_yieldk`, the running coroutine suspends its execution, and the\ncall to `lua_resume` that started this coroutine returns.  The parameter `nresults` is the\nnumber of values from the stack that will be passed as results to `lua_resume`.\n\nWhen the coroutine is resumed again, Lua calls the given continuation function `k` to continue\nthe execution of the C function that yielded (see §4.5).  This continuation function receives\nthe same stack from the previous function, with the `n` results removed and replaced by the\narguments passed to `lua_resume`.  Moreover, the continuation function receives the value `ctx`\nthat was passed to `lua_yield`.\n\nUsually, this function does not return; when the coroutine eventually resumes, it continues\nexecuting the continuation function.  However, there is one special case, which is when this\nfunction is called from inside a line or a count hook (see §4.7).  In that case, `lua_yieldk`\nshould be called with no continuation (probably in the form of `lua_yield` and no results),\nand the hook should return immediately after the call.  Lua will yield and, when the coroutine\nresumes again, it will continue the normal execution of the (Lua) function that triggered the hook.\n\nThis function can raise an error if it is called from a thread with a pending C call with no\ncontinuation function (what is called a *C-call boundary*), or it is called from a thread that\nis not running inside a resume (typically the main thread).\n
lua_Debug lua_Debug [struct]\ntypedef struct lua_Debug {\n  int event;\n  const char *name;           /* (n) */\n  const char *namewhat;       /* (n) */\n  const char *what;           /* (S) */\n  const char *source;         /* (S) */\n  size_t srclen;              /* (S) */\n  int currentline;            /* (l) */\n  int linedefined;            /* (S) */\n  int lastlinedefined;        /* (S) */\n  unsigned char nups;         /* (u) number of upvalues */\n  unsigned char nparams;      /* (u) number of parameters */\n  char isvararg;              /* (u) */\n  char istailcall;            /* (t) */\n  unsigned short ftransfer;   /* (r) index of first value transferred */\n  unsigned short ntransfer;   /* (r) number of transferred values */\n  char short_src[LUA_IDSIZE]; /* (S) */\n  /* private part */\n  _other fields_\n} lua_Debug;\n\nA structure used to carry different pieces of information about a function or an activation record.\n`lua_getstack` fills only the private part of this structure, for later use.  To fill the other\nfields of `lua_Debug` with useful information, you must call `lua_getinfo`.\n\nThe fields of `lua_Debug` have the following meaning:\n\n  * source: the source of the chunk that created the function.  If `source` starts with a '`@`',\n    it means that the function was defined in a file where the file name follows the '`@`'.\n    If `source` starts with a '`=`', the remainder of its contents describes the source in\n    a user-dependent manner.  Otherwise, the function was defined in a string where `source`\n    is that string.\n  * srclen: The length of the string `source`.\n  * short_src: a "printable" version of `source`, to be used in error messages.\n  * linedefined: the line number where the definition of the function starts.\n  * lastlinedefined: the line number where the definition of the function ends.\n  * what: the string "Lua" if the function is a Lua function, "C" if it is a C function, "main"\n    if it is the main part of a chunk.\n  * currentline: the current line where the given function is executing.  When no line information\n    is available, `currentline` is set to -1.\n  * name: a reasonable name for the given function.  Because functions in Lua are first-class\n    values, they do not have a fixed name: some functions can be the value of multiple global\n    variables, while others can be stored only in a table field.  The `lua_getinfo` function\n    checks how the function was called to find a suitable name.  If it cannot find a name,\n    then `name` is set to `NULL`.\n  * namewhat: explains the `name` field.  The value of `namewhat` can be "global", "local",\n    "method", "field", "upvalue", or "" (the empty string), according to how the function\n    was called.  (Lua uses the empty string when no other option seems to apply.)\n  * istailcall: true if this function invocation was called by a tail call.  In this case,\n    the caller of this level is not in the stack.\n  * nups: the number of upvalues of the function.\n  * nparams: the number of parameters of the function (always 0 for C functions).\n  * isvararg: true if the function is a vararg function (always true for C functions).\n  * ftransfer: the index in the stack of the first value being "transferred", that is, parameters\n    in a call or return values in a return. (The other values are in consecutive indices.)\n    Using this index, you can access and modify these values through `lua_getlocal` and\n    `lua_setlocal`.  This field is only meaningful during a call hook, denoting the first\n    parameter, or a return hook, denoting the first value being returned.  (For call hooks,\n    this value is always 1.)\n  * ntransfer: The number of values being transferred (see previous item).  (For calls of Lua\n    functions, this value is always equal to `nparams`.)\n
lua_gethook lua_gethook(lua_State *L) [lua_Hook]\nReturns the current hook function.\n
lua_gethookcount lua_gethookcount(lua_State *L) [int]\nReturns the current hook count.\n
lua_gethookmask lua_gethookmask(lua_State *L) [int]\nReturns the current hook mask.\n
lua_getinfo lua_getinfo(lua_State *L, const char *what, lua_Debug *ar) [int]\nGets information about a specific function or function invocation.\n\nTo get information about a function invocation, the parameter `ar` must be a valid activation\nrecord that was filled by a previous call to `lua_getstack` or given as argument to a hook (see\n`lua_Hook`).\n\nTo get information about a function you push it onto the stack and start the `what` string with\nthe character '>'.  (In that case, `lua_getinfo` pops the function from the top of the stack.)\nFor instance, to know in which line a function `f` was defined, you can write the following code:\n\n  lua_Debug ar;\n  lua_getglobal(L, "f");  /* get global 'f' */\n  lua_getinfo(L, ">S", &ar);\n  printf("%d\n", ar.linedefined);\n\nEach character in the string `what` selects some fields of the structure `ar` to be filled or\na value to be pushed on the stack:\n\n  * 'n': fills in the field `name` and `namewhat`;\n  * 'S': fills in the fields `source`, `short_src`, `linedefined`, `lastlinedefined`, and `what`;\n  * 'l': fills in the field `currentline`;\n  * 't': fills in the field `istailcall`;\n  * 'u': fills in the fields `nups`, `nparams`, and `isvararg`;\n  * 'f': pushes onto the stack the function that is running at the given level;\n  * 'L': pushes onto the stack a table whose indices are the numbers of the lines that are\n    valid on the function.  (A _valid line_ is a line with some associated code, that is,\n    a line where you can put a break point.  Non-valid lines include empty lines and comments.)\n\n    If this option is given together with option 'f', its table is pushed after the function.\n\n    This is the only option that can raise a memory error.\n\nThis function returns 0 to signal an invalid option in `what`; even then the valid options are\nhandled correctly.\n
lua_getlocal lua_getlocal(lua_State *L, const lua_Debug *ar, int n) [const char*]\nGets information about a local variable or a temporary value of a given activation record or\na given function.\n\nIn the first case, the parameter `ar` must be a valid activation record that was filled by a\nprevious call to `lua_getstack` or given as argument to a hook (see `lua_Hook`).  The index\n`n` selects which local variable to inspect; see `debug.getlocal` for details about variable\nindices and names.\n\n`lua_getlocal` pushes the variable's value onto the stack and returns its name.\n\nIn the second case, `ar` must be `NULL` and the function to be inspected must be on the top\nof the stack.  In this case, only parameters of Lua functions are visible (as there is no\ninformation about what variables are active) and no values are pushed onto the stack.\n\nReturns `NULL` (and pushes nothing) when the index is greater than the number of active local\nvariables.\n
lua_getstack lua_getstack(lua_State *L, int level, lua_Debug *ar) [int]\nGets information about the interpreter runtime stack.\n\nThis function fills parts of a `lua_Debug` structure with an identification of the _activation\nrecord_ of the function executing at a given level.  Level 0 is the current running function,\nwhereas level _n+1_ is the function that has called level _n_ (except for tail calls, which do\nnot count in the stack).  When called with a level greater than the stack depth, `lua_getstack`\nreturns 0; otherwise it returns 1.\n
lua_getupvalue lua_getupvalue(lua_State *L, int funcindex, int n) [const char*]\nGets information about the `n`-th upvalue of the closure at index `funcindex`.  It pushes\nthe upvalue's value onto the stack and returns its name.  Returns `NULL` (and pushes nothing)\nwhen the index `n` is greater than the number of upvalues.\n\nSee `debug.getupvalue` for more information about upvalues.\n
lua_Hook (*lua_Hook)(lua_State *L, lua_Debug *ar) [void]\nType for debugging hook functions.\n\nWhenever a hook is called, its `ar` argument has its field `event` set to the specific event that\ntriggered the hook.  Lua identifies these events with the following constants: `LUA_HOOKCALL`,\n`LUA_HOOKRET`, `LUA_HOOKTAILCALL`, `LUA_HOOKLINE`, and `LUA_HOOKCOUNT`.  Moreover, for line\nevents, the field `currentline` is also set.  To get the value of any other field in `ar`,\nthe hook must call `lua_getinfo`.\n\nFor call events, `event` can be `LUA_HOOKCALL`, the normal value, or `LUA_HOOKTAILCALL`, for\na tail call; in this case, there will be no corresponding return event.\n\nWhile Lua is running a hook, it disables other calls to hooks.  Therefore, if a hook calls back\nLua to execute a function or a chunk, this execution occurs without any calls to hooks.\n\nHook functions cannot have continuations, that is, they cannot call `lua_yieldk`, `lua_pcallk`,\nor `lua_callk` with a non-null `k`.\n\nHook functions can yield under the following conditions: Only count and line events can yield\nand they cannot yield any value; to yield a hook function must finish its execution calling\n`lua_yield` with `nresults` equal to zero.\n
lua_sethook lua_sethook(lua_State *L, lua_Hook f, int mask, int count) [void]\nSets the debugging hook function.\n\nArgument `f` is the hook function.\n\n`mask` specifies on which events the hook will be called: it is formed by a bitwise OR of the\nconstants `LUA_MASKCALL`, `LUA_MASKRET`, `LUA_MASKLINE`, and `LUA_MASKCOUNT`.  The `count`\nargument is only meaningful when the mask includes `LUA_MASKCOUNT`.  For each event, the hook\nis called as explained below:\n\n  * The call hook: is called when the interpreter calls a function.  The hook is called just\n    after Lua enters the new function.\n  * The return hook: is called when the interpreter returns from a function.  The hook is called\n    just before Lua leaves the function.\n  * The line hook: is called when the interpreter is about to start the execution of a new\n    line of code, or when it jumps back in the code (even to the same line).  This event only\n    happens while Lua is executing a Lua function.\n  * The count hook: is called after the interpreter executes every `count` instructions.\n    This event only happens while Lua is executing a Lua function.\n\nHooks are disabled by setting `mask` to zero.\n
lua_setlocal lua_setlocal(lua_State *L, const lua_Debug *ar, int n) [const char*]\nSets the value of a local variable of a given activation record.  Parameters `ar` and `n` are\nas in `lua_getlocal` (see `lua_getlocal`).  `lua_setlocal` assigns the value on the top of the\nstack to the variable and returns its name.  It also pops the value from the stack.\n\nReturns `NULL` (and pops nothing) when the index is greater than the number of active local\nvariables.\n\nParameters `ar` and `n` are as in the function `lua_getlocal`.\n
lua_setupvalue lua_setupvalue(lua_State *L, int funcindex, int n) [const char*]\nSets the value of a closure's upvalue.  It assigns the value on the top of the stack to the\nupvalue and returns its name.  It also pops the value from the stack.  Parameters `funcindex`\nand `n` are as in the `lua_getupvalue` (see `lua_getupvalue`).\n\nReturns `NULL` (and pops nothing) when the index is greater than the number of upvalues.\n\nParameters `funcindex` and `n` are as in the function `lua_getupvalue`.\n
lua_upvalueid lua_upvalueid(lua_State *L, int funcindex, int n) [void*]\nReturns a unique identifier for the upvalue numbered `n` from the closure at index `funcindex`.\nParameters `funcindex` and `n` are as in the `lua_getupvalue` (see `lua_getupvalue`) (but `n`\ncannot be greater than the number of upvalues).\n\nThese unique identifiers allow a program to check whether different closures share upvalues.\nLua closures that share an upvalue (that is, that access a same external local variable) will\nreturn identical ids for those upvalue indices.\n\nParameters `funcindex` and `n` are as in the function `lua_getupvalue`, but `n` cannot be\ngreater than the number of upvalues.\n
lua_upvaluejoin lua_upvaluejoin(lua_State *L, int funcindex1, int n1, int funcindex2, int n2) [void]\nMake the `n1`-th upvalue of the Lua closure at index `funcindex1` refer to the `n2`-th upvalue\nof the Lua closure at index `funcindex2`.\n
luaL_addchar luaL_addchar(luaL_Buffer *B, char c) [void]\nAdds the byte `c` to the buffer `B` (see `luaL_Buffer`).\n
luaL_addgsub luaL_addgsub(luaL_Buffer *B, const char *s, const char *p, const char *r) [const void]\nAdds a copy of the string `s` to the buffer `B` (see `luaL_Buffer`), replacing any occurrence\nof the string `p` with the string `r`.\n
luaL_addlstring luaL_addlstring(luaL_Buffer *B, const char *s, size_t l) [void]\nAdds the string pointed to by `s` with length `l` to the buffer `B` (see `luaL_Buffer`).\nThe string can contain embedded zeros.\n
luaL_addsize luaL_addsize(luaL_Buffer *B, size_t n) [void]\nAdds to the buffer `B` a string of length `n` previously copied to the buffer area (see\n`luaL_prepbuffer`).\n
luaL_addstring luaL_addstring(luaL_Buffer *B, const char *s) [void]\nAdds the zero-terminated string pointed to by `s` to the buffer `B` (see `luaL_Buffer`).\n
luaL_addvalue luaL_addvalue(luaL_Buffer *B) [void]\nAdds the value on the top of the stack to the buffer `B` (see `luaL_Buffer`).  Pops the value.\n\nThis is the only function on string buffers that can (and must) be called with an extra element\non the stack, which is the value to be added to the buffer.\n
luaL_argcheck luaL_argcheck(lua_State *L, int cond, int arg, const char *extramsg) [void]\nChecks whether `cond` is true.  If it is not, raises an error with a standard message (see\n`luaL_argerror`).\n
luaL_argerror luaL_argerror(lua_State *L, int arg, const char *extramsg) [int]\nRaises an error reporting a problem with argument `arg` of the C function that called it,\nusing a standard message that includes `extramsg` as a comment:\n\n     bad argument #_arg_ to '_funcname_' (_extramsg_)\n\nThis function never returns.\n
luaL_argexpected luaL_argexpected(lua_State *L, int cond, int arg, const char *tname) [void]\nChecks whether `cond` is true.  If it is not, raises an error about the type of the argument\n`arg` with a standard message (see `luaL_typeerror`).\n
luaL_Buffer luaL_Buffer [struct]\nType for a _string buffer_.\n\nA string buffer allows C code to build Lua strings piecemeal.  Its pattern of use is as follows:\n\n  * First declare a variable `b` of type `luaL_Buffer`.\n  * Then initialize it with a call `luaL_buffinit(L, &b)`.\n  * Then add string pieces to the buffer calling any of the `luaL_add*` functions.\n  * Finish by calling `luaL_pushresult(&b)`.  This call leaves the final string on the top of\n    the stack.\n\nIf you know beforehand the maximum size of the resulting string, you can use the buffer like this:\n\n  * First declare a variable `b` of type `luaL_Buffer`.\n  * Then initialize it and preallocate a space of size `sz` with a call\n    `luaL_buffinitsize(L, &b, sz)`.\n  * Then produce the string into that space.\n  * Finish by calling `luaL_pushresultsize(&b, sz)`, where `sz` is the total size of the resulting\n    string copied into that space (which may be less than or equal to the preallocated size).\n\nDuring its normal operation, a string buffer uses a variable number of stack slots.  So,\nwhile using a buffer, you cannot assume that you know where the top of the stack is.  You can\nuse the stack between successive calls to buffer operations as long as that use is balanced;\nthat is, when you call a buffer operation, the stack is at the same level it was immediately\nafter the previous buffer operation.  (The only exception to this rule is `luaL_addvalue`.)\nAfter calling `luaL_pushresult`, the stack is back to its level when the buffer was initialized,\nplus the final string on its top.\n
luaL_buffaddr luaL_buffaddr(luaL_Buffer *B) [char*]\nReturns the address of the current content of buffer `B` (see `luaL_Buffer`).  Note that any\naddition to the buffer may invalidate this address.\n
luaL_buffinit luaL_buffinit(lua_State *L, luaL_Buffer *B) [void]\nInitializes a buffer `B` (see `luaL_Buffer`).  This function does not allocate any space;\nthe buffer must be declared as a variable.\n
luaL_bufflen luaL_bufflen(luaL_Buffer *B) [size_t]\nReturns the length of the current content of buffer `B` (see `luaL_Buffer`).\n
luaL_buffinitsize luaL_buffinitsize(lua_State *L, luaL_Buffer *B, size_t sz) [char*]\nEquivalent to the sequence `luaL_buffinit`, `luaL_prepbuffsize`.\n
luaL_buffsub luaL_buffsub(luaL_Buffer *B, int n) [void]\nRemoves `n` bytes from the the buffer `B` (see `luaL_Buffer`).  The buffer must have at least\nthat many bytes.\n
luaL_callmeta luaL_callmeta(lua_State *L, int obj, const char *e) [int]\nCalls a metamethod.\n\nIf the object at index `obj` has a metatable and this metatable has a field `e`, this function\ncalls this field passing the object as its only argument.  In this case this function returns\ntrue and pushes onto the stack the value returned by the call.  If there is no metatable or no\nmetamethod, this function returns false without pushing any value on the stack.\n
luaL_checkany luaL_checkany(lua_State *L, int arg) [void]\nChecks whether the function has an argument of any type (including nil) at position `arg`.\n
luaL_checkinteger luaL_checkinteger(lua_State *L, int arg) [lua_Integer]\nChecks whether the function argument `arg` is an integer (or can be converted to an integer)\nand returns this integer.\n
luaL_checklstring luaL_checklstring(lua_State *L, int arg, size_t *l) [const char*]\nChecks whether the function argument `arg` is a string and returns this string; if `l` is not\n`NULL` fills its referent with the string's length.\n\nThis function uses `lua_tolstring` to get its result, so all conversions and caveats of that\nfunction apply here.\n
luaL_checknumber luaL_checknumber(lua_State *L, int arg) [lua_Number]\nChecks whether the function argument `arg` is a number and returns this number converted to a\n`lua_Number`.\n
luaL_checkoption luaL_checkoption(lua_State *L, int arg, const char *def, const char *const lst[]) [int]\nChecks whether the function argument `arg` is a string and searches for this string in the array\n`lst` (which must be NULL-terminated).  Returns the index in the array where the string was found.\nRaises an error if the argument is not a string or if the string cannot be found.\n\nIf `def` is not `NULL`, the function uses `def` as a default value when there is no argument\n`arg` or when this argument is nil.\n\nThis is a useful function for mapping strings to C enums.  (The usual convention in Lua libraries\nis to use strings instead of numbers to select options.)\n
luaL_checkstack luaL_checkstack(lua_State *L, int sz, const char *msg) [void]\nGrows the stack size to `top + sz` elements, raising an error if the stack cannot grow to that\nsize.  `msg` is an additional text to go into the error message (or `NULL` for no additional text).\n
luaL_checkstring luaL_checkstring(lua_State *L, int arg) [const char*]\nChecks whether the function argument `arg` is a string and returns this string.\n\nThis function uses `lua_tolstring` to get its result, so all conversions and caveats of that\nfunction apply here.\n
luaL_checktype luaL_checktype(lua_State *L, int arg, int t) [void]\nChecks whether the function argument `arg` has type `t`.  See `lua_type` for the encoding of\ntypes for `t`.\n
luaL_checkudata luaL_checkudata(lua_State *L, int arg, const char *tname) [void*]\nChecks whether the function argument `arg` is a userdata of the type `tname` (see\n`luaL_newmetatable`) and returns the userdata's memory-block address (see `lua_touserdata`).\n
luaL_checkversion luaL_checkversion(lua_State *L) [void]\nChecks whether the code making the call and the Lua library being called are using the same\nversion of Lua and the same numeric types.\n
luaL_dofile luaL_dofile(lua_State *L, const char *filename) [int]\nLoads and runs the given file.  It is defined as the following macro:\n\n  (luaL_loadfile(L, filename) || lua_pcall(L, 0, LUA_MULTRET, 0))\n\nIt returns `LUA_OK` if there are no errors, or an error code in case of errors (see §4.4.1).\n
luaL_dostring luaL_dostring(lua_State *L, const char *str) [int]\nLoads and runs the given string.  It is defined as the following macro:\n\n  (luaL_loadstring(L, str) || lua_pcall(L, 0, LUA_MULTRET, 0))\n\nIt returns `LUA_OK` if there are no errors, or an error code in case of errors (see §4.4.1).\n
luaL_error luaL_error(lua_State *L, const char *fmt, ...) [int]\nRaises an error.  The error message format is given by `fmt` plus any extra arguments, following\nthe same rules of `lua_pushfstring`.  It also adds at the beginning of the message the file\nname and the line number where the error occurred, if this information is available.\n\nThis function never returns, but it is an idiom to use it in C functions as `return\nluaL_error(args)`.\n
luaL_execresult luaL_execresult(lua_State *L, int stat) [int]\nThis function produces the return values for process-related functions in the standard library\n(`os.execute` and `io.close`).\n
luaL_fileresult luaL_fileresult(lua_State *L, int stat, const char *fname) [int]\nThis function produces the return values for file-related functions in the standard library\n(`io.open`, `os.rename`, `file:seek`, etc.).\n
luaL_getmetafield luaL_getmetafield(lua_State *L, int obj, const char *e) [int]\nPushes onto the stack the field `e` from the metatable of the object at index `obj` and returns\nthe type of pushed value.  If the object does not have a metatable, or if the metatable does\nnot have this field, pushes nothing and returns `LUA_TNIL`.\n
luaL_getmetatable luaL_getmetatable(lua_State *L, const char *tname) [int]\nPushes onto the stack the metatable associated with the name `tname` in the registry (see\n`luaL_newmetatable`), or nil if there is no metatable associated with that name.  Returns the\ntype of that pushed value.\n
luaL_getsubtable luaL_getsubtable(lua_State *L, int idx, const char *fname) [int]\nEnsures that the value `t[fname]`, where `t` is the value at index `idx`, is a table, and\npushes that table onto the stack.  Returns true if it finds a previous table there and false\nif it creates a new table.\n
luaL_gsub luaL_gsub(lua_State *L, const char *s, const char *p, const char *r) [const char*]\nCreates a copy of string `s`, replacing any occurrence of the string `p` with the string `r`.\nPushes the resulting string on the stack and returns it.\n
luaL_len luaL_len(lua_State *L, int index) [lua_Integer]\nReturns the "length" of the value at the given index as a number; it is equivalent to the '`#`'\noperator in Lua (see §3.4.7).  Raises an error if the result of the operation is not an integer.\n(This case can only happen through metamethods.)\n
luaL_loadbuffer luaL_loadbuffer(lua_State *L, const char *buff, size_t sz, const char *name) [int]\nEquivalent to `luaL_loadbufferx` with `mode` equal to `NULL`.\n
luaL_loadbufferx luaL_loadbufferx(lua_State *L, const char *buff, size_t sz, const char *name, const char *mode) [int]\nLoads a buffer as a Lua chunk.  This function uses `lua_load` to load the chunk in the buffer\npointed to by `buff` with size `sz`.\n\nThis function returns the same results as `lua_load`.  `name` is the chunk name, used for debug\ninformation and error messages.  The string `mode` works as in the function `lua_load`.\n
luaL_loadfile luaL_loadfile(lua_State *L, const char *filename) [int]\nEquivalent to `luaL_loadfilex` with `mode` equal to `NULL`.\n
luaL_loadfilex luaL_loadfilex(lua_State *L, const char *filename, const char *mode) [int]\nLoads a file as a Lua chunk.  This function uses `lua_load` to load the chunk in the file named\n`filename`.  If `filename` is `NULL`, then it loads from the standard input.  The first line\nin the file is ignored if it starts with a `#`.\n\nThe string `mode` works as in the function `lua_load`.\n\nThis function returns the same results as `lua_load` or `LUA_ERRFILE` for file-related errors.\n\nAs `lua_load`, this function only loads the chunk; it does not run it.\n
luaL_loadstring luaL_loadstring(lua_State *L, const char *s) [int]\nLoads a string as a Lua chunk.  This function uses `lua_load` to load the chunk in the\nzero-terminated string `s`.\n\nThis function returns the same results as `lua_load`.\n\nAlso as `lua_load`, this function only loads the chunk; it does not run it.\n
luaL_newlib luaL_newlib(lua_State *L, const luaL_Reg l[]) [void]\nCreates a new table and registers there the functions in the list `l`.\n\nIt is implemented as the following macro:\n\n  (luaL_newlibtable(L,l), luaL_setfuncs(L,l,0))\n\nThe array `l` must be the actual array, not a pointer to it.\n
luaL_newlibtable luaL_newlibtable(lua_State *L, const luaL_Reg l[]) [void]\nCreates a new table with a size optimized to store all entries in the array `l` (but does\nnot actually store them).  It is intended to be used in conjunction with `luaL_setfuncs` (see\n`luaL_newlib`).\n\nIt is implemented as a macro.  The array `l` must be the actual array, not a pointer to it.\n
luaL_newmetatable luaL_newmetatable(lua_State *L, const char *tname) [int]\nIf the registry already has the key `tname`, returns 0.  Otherwise, creates a new table to be\nused as a metatable for userdata, adds to this new table the pair `__name = tname`, adds to\nthe registry the pair `[tname] = new table`, and returns 1.\n\nIn both cases, the function pushes onto the stack the final value associated with `tname`\nin the registry.\n
luaL_newstate luaL_newstate(void) [lua_State*]\nCreates a new Lua state.  It calls `lua_newstate` with an allocator based on the standard C\nallocation functions and then sets a warning function and a panic function (see §4.4) that\nprint messages to the standard error output.\n\nReturns the new state, or `NULL` if there is a memory allocation error.\n
luaL_openlibs luaL_openlibs(lua_State *L) [void]\nOpens all standard Lua libraries into the given state.\n
luaL_opt luaL_opt(L, func, arg, dflt);\nThis macro is defined as follows:\n\n    (lua_isnoneornil(L,(arg)) ? (dflt) : func(L,(arg)))\n\nIn words, if the argument `arg` is nil or absent, the macro results in the default `dflt`.\nOtherwise, it results in the result of calling `func` with the state `L` and the argument index\n`arg` as parameters.  Note that it evaluates the expression `dflt` only if needed.\n
luaL_optinteger luaL_optinteger(lua_State *L, int arg, lua_Integer d) [lua_Integer]\nIf the function argument `arg` is an integer (or it is convertable to an integer), returns\nthis integer.  If this argument is absent or is nil, returns `d`.  Otherwise, raises an error.\n
luaL_optlstring luaL_optlstring(lua_State *L, int arg, const char *d, size_t *l) [const char*]\nIf the function argument `arg` is a string, returns this string.  If this argument is absent\nor is nil, returns `d`.  Otherwise, raises an error.\n\nIf `l` is not `NULL`, fills its referent with the result's length.  If the result is `NULL`\n(only possible when returning `d` and `d == NULL`), its length is considered zero.\n
luaL_optnumber luaL_optnumber(lua_State *L, int arg, lua_Number d) [lua_Number]\nIf the function argument `arg` is a number, returns this number as a `lua_Number`.  If this\nargument is absent or is nil, returns `d`.  Otherwise, raises an error.\n
luaL_optstring luaL_optstring(lua_State *L, int arg, const char *d) [const char*]\nIf the function argument `arg` is a string, returns this string.  If this argument is absent\nor is nil, returns `d`.  Otherwise, raises an error.\n
luaL_prepbuffer luaL_prepbuffer(luaL_Buffer *B) [char*]\nEquivalent to `luaL_prepbuffsize` with the predefined size `LUAL_BUFFERSIZE`.\n
luaL_prepbuffsize luaL_prepbuffsize(luaL_Buffer *B, size_t sz) [char*]\nReturns an address to a space of size `LUAL_BUFFERSIZE` where you can copy a string to be added\nto buffer `B` (see `luaL_Buffer`).  After copying the string into this space you must call\n`luaL_addsize` with the size of the string to actually add it to the buffer.\n
luaL_pushfail luaL_pushfail(lua_State *L) [void]\nPushes the fail value onto the stack (see §6).\n
luaL_pushresult luaL_pushresult(luaL_Buffer *B) [void]\nFinishes the use of buffer `B` leaving the final string on the top of the stack.\n
luaL_pushresultsize luaL_pushresultsize(luaL_Buffer *B, size_t sz) [void]\nEquivalent to the sequence `luaL_addsize`, `luaL_pushresult`.\n
luaL_ref luaL_ref(lua_State *L, int t) [int]\nCreates and returns a _reference_, in the table at index `t`, for the object on the top of the\nstack (and pops the object).\n\nA reference is a unique integer key.  As long as you do not manually add integer keys into the\ntable `t`, `luaL_ref` ensures the uniqueness of the key it returns.  You can retrieve an object\nreferred by the reference `r` by calling `lua_rawgeti(L, t, r)`.  The function `luaL_unref`\nfrees a reference.\n\nIf the object on the top of the stack is nil, `luaL_ref` returns the constant `LUA_REFNIL`.\nThe constant `LUA_NOREF` is guaranteed to be different from any reference returned by `luaL_ref`.\n
luaL_Reg luaL_Reg [struct]\ntypedef struct luaL_Reg {\n  const char *name;\n  lua_CFunction func;\n} luaL_Reg;\n\nType for arrays of functions to be registered by `luaL_setfuncs is the function name and `func`\nis a pointer to the function.  Any array of `luaL_Reg` must end with a sentinel entry in which\nboth `name` and `func` are `NULL`.\n
luaL_requiref luaL_requiref(lua_State *L, const char *modname, lua_CFunction openf, int glb) [void]\nIf `package.loaded[modname]` is not true, calls the function `openf` with the string `modname`\nas an argument and sets the call result to `package.loaded[modname]`, as if that function has\nbeen called through `require`.\n\nIf `glb` is true, also stores the module into the global `modname`.\n\nLeaves a copy of the module on the stack.\n
luaL_setfuncs luaL_setfuncs(lua_State *L, const luaL_Reg *l, int nup) [void]\nRegisters all functions in the array `l` (see `luaL_Reg`) into the table on the top of the stack\n(below optional upvalues, see next).\n\nWhen `nup` is not zero, all functions are created with `nup` upvalues, initialized with copies\nof the `nup` values previously pushed on the stack on top of the library table.  These values\nare popped from the stack after the registration.\n
luaL_setmetatable luaL_setmetatable(lua_State *L, const char *tname) [void]\nSets the metatable of the object on the top of the stack as the metatable associated with name\n`tname` in the registry (see `luaL_newmetatable`).\n
luaL_Stream luaL_Stream [typedef struct luaL_Stream {FILE *f; lua_CFunction closef;}]\nThe standard representation for file handles used by the standard I/O library.\n\nA file handle is implemented as a full userdata, with a metatable called `LUA_FILEHANDLE`\n(where `LUA_FILEHANDLE` is a macro with the actual metatable's name).  The metatable is created\nby the I/O library (see `luaL_newmetatable`).\n\nThis userdata must start with the structure `luaL_Stream`; it can contain other data after this\ninitial structure.  The field `f` points to the corresponding C stream (or it can be `NULL`\nto indicate an incompletely created handle).  The field `closef` points to a Lua function\nthat will be called to close the stream when the handle is closed or collected; this function\nreceives the file handle as its sole argument and must return either a true value, in case of\nsuccess, or a false value plus an error message, in case of error.  Once Lua calls this field,\nit changes the field value to `NULL` to signal that the handle is closed.\n
luaL_testudata luaL_testudata(lua_State *L, int arg, const char *tname) [void]\nThis function works like `luaL_checkudata`, except that, when the test fails, it returns `NULL`\ninstead of raising an error.\n
luaL_tolstring luaL_tolstring(lua_State *L, int idx, size_t *len) [const char*]\nConverts any Lua value at the given index to a C string in a reasonable format.  The resulting\nstring is pushed onto the stack and also returned by the function (see §4.1.3).  If `len`\nis not `NULL`, the function also sets `*len` with the string length.\n\nIf the value has a metatable with a `__tostring` field, then `luaL_tolstring` calls the\ncorresponding metamethod with the value as argument, and uses the result of the call as its result.\n
luaL_traceback luaL_traceback(lua_State *L, lua_State *L1, const char *msg, int level) [void]\nCreates and pushes a traceback of the stack `L1`.  If `msg` is not `NULL`, it is appended at\nthe beginning of the traceback.  The `level` parameter tells at which level to start the traceback.\n
luaL_typeerror luaL_typeerror(lua_State *L, int arg, const char *tname) [const char*]\nRaises a type error for the argument `arg` of the C function that called it, using a standard\nmessage; `tname` is a "name" for the expected type.  This function never returns.\n
luaL_typename luaL_typename(lua_State *L, int index) [const char*]\nReturns the name of the type of the value at the given index.\n
luaL_unref luaL_unref(lua_State *L, int t, int ref) [void]\nReleases the reference `ref` from the table at index `t` (see `luaL_ref`).  The entry is\nremoved from the table, so that the referred object can be collected.  The reference `ref`\nis also freed to be used again.\n\nIf `ref` is `LUA_NOREF` or `LUA_REFNIL`, `luaL_unref` does nothing.\n
luaL_where luaL_where(lua_State *L, int lvl) [void]\nPushes onto the stack a string identifying the current position of the control at level `lvl`\nin the call stack.  Typically this string has the following format:\n\n  _chunkname_:_currentline_:\n\nLevel 0 is the running function, level 1 is the function that called the running function, etc.\n\nThis function is used to build a prefix for error messages.\n
