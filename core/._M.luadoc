-- Copyright 2007-2022 Mitchell. See LICENSE.
-- This is a DUMMY FILE used for making LuaDoc for built-in functions in the global _M table.

---
-- A table of loaded Textadept language modules.
--
-- Language modules are a special kind of module that Textadept automatically loads when editing
-- source code in a particular programming language. The only thing "special" about them is they
-- are named after a lexer. Otherwise they are plain Lua modules. The *~/.textadept/modules/*
-- directory houses language modules (along with other modules).
--
-- A language module is designed to provide extra functionality for a single programming
-- language. Some examples of what language modules can do:
--
--   * Specify block comment syntax for lines of code
--   * Define compile and run commands for source files
--   * Set language-specific editor properties like indentation rules
--   * Specify code autocompletion routines
--   * Declare snippets
--   * Define commands and key bindings for them
--   * Add to the top-level menu or right-click editor context menu
--
-- Examples of these features are described in the sections below.
--
-- ### Block Comment
--
-- Many languages have different syntaxes for single line comments and multi-line comments in
-- source code. Textadept's block comment feature only uses one of those syntaxes for a given
-- language. If you prefer the other syntax, or if Textadept does not support block comments
-- for a particular language, modify the [`textadept.editing.comment_string`]() table. For example:
--
--     textadept.editing.comment_string.ansi_c = '/*|*/' -- change from //
--
-- ### Compile and Run
--
-- Textadept knows most of the commands that compile and/or run code in source files. However,
-- it does not know all of them, and the ones that it does know may not be completely accurate
-- in all cases. Compile and run commands are read from the [`textadept.run.compile_commands`]()
-- and [`textadept.run.run_commands`]() tables using the appropriate lexer name key, and thus
-- can be defined or modified. For Lua, it would look like:
--
--     textadept.run.compile_commands.lua = 'luac "%f"'
--     textadept.run.run_commands.lua = 'lua "%f"'
--
-- Double-clicking on compile or runtime errors jumps to the error's location. If Textadept
-- does not recognize your language's errors properly, add a grammar [rule](#rules) to the
-- *lexers/output.lua* lexer.
--
-- ### Buffer Properties
--
-- By default, Textadept uses 2 spaces for indentation. Some languages have different indentation
-- guidelines, however. As described in the manual, use `events.LEXER_LOADED` to change this
-- and any other language-specific editor properties. For example:
--
--     events.connect(events.LEXER_LOADED, function(name)
--       if name ~= 'python' then return end
--       buffer.tab_width = 4
--       buffer.use_tabs = false
--       view.view_ws = view.WS_VISIBLEALWAYS
--     end)
--
-- ### Autocompletion and Documentation
--
-- Textadept has the capability to autocomplete symbols for programming
-- languages and display API documentation. In order for these to work for a
-- given language, an [autocompleter](#textadept.editing.autocompleters) and [API
-- file(s)](#textadept.editing.api_files) must exist. All of Textadept's included language
-- modules have examples of autocompleters and API documentation, as well as most of its
-- officially supported language modules.
--
-- ### Snippets
--
-- [Snippets](#textadept.snippets) for common language constructs are useful. Some snippets
-- for common Lua control structures look like this:
--
--     snippets.lua = {
--       f = "function %1(name)(%2(args))\n\t%0\nend",
--       ['for'] = "for i = %1(1), %2(10)%3(, -1) do\n\t%0\nend",
--       fori = "for %1(i), %2(val) in ipairs(%3(table)) do\n\t%0\nend",
--       forp = "for %1(k), %2(v) in pairs(%3(table)) do\n\t%0\nend",
--     }
--
-- ### Commands
--
-- Additional editing features for the language can be useful. For example, a C++ module might
-- have a feature to add a ';' to the end of the current line and insert a new line. This command
-- could be bound to the `Shift+Enter` (`⇧↩` on macOS | `S-Enter` in the terminal version)
-- key for easy access:
--
--     keys.cpp['shift+\n'] = function()
--       buffer:line_end()
--       buffer:add_text(';')
--       buffer:new_line()
--     end
--
-- ### Menus
--
-- It may be useful to add language-specific menu options to the top-level menu and/or right-click
-- context menu in order to access module features without using key bindings. For example:
--
--     local lua_menu = {
--       title = 'Lua',
--       {'Item 1', function() ... end},
--       {'Item 2', function() ... end}
--     }
--     local tools = textadept.menu.menubar[_L['Tools']]
--     tools[#tools + 1] = lua_menu
--     textadept.menu.context_menu[#textadept.menu.context_menu + 1] = lua_menu
module('_M')
